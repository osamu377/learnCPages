# ループ処理



![最適なループの見つけ方](img/p1c5.jpg)

## 1. はじめに：なぜループ処理が重要なのか？

ソフトウェアを開発する上で、同じ、あるいは類似した処理を何度も繰り返す場面は避けて通れません。この「反復処理」を効率的に、そして読みやすく記述するための基本構造が「ループ」です。ループを、あなたのソフトウェアの「組立ライン」だと考えてみてください。もし組立ラインがなければ、一つひとつの製品を手作業で組み立てるしかなく、それは遅く、間違いの多いプロセスになるでしょう。ループ処理をマスターすることは、データのための強力で自動化された工場を建設するようなものです。プログラムを学び始めた皆さんがこのスキルを最初に習得することは、その後の成長を大きく左右する、極めて重要なステップなのです。

C言語におけるループとは、シンプルに「特定のコードブロックを複数回実行する機能」と定義されます。C言語にはいくつかのループ構文が用意されており、それぞれに得意な処理や設計思想が存在します。

本ガイドでは、C言語における最も代表的な2つのループ、forループとwhileループに焦点を当て、その仕組みから実践的な使い方、そして高度な制御方法までを解説します。このガイドを読み終える頃には、状況に応じて最適なループを選択し、意図通りにプログラムを制御する自信が身についているはずです。

## 2. forループ：回数が決まっている反復処理

forループは、C言語において最も一般的で、構造化された反復処理の形式です。その最大の特長は、ループのライフサイクルを管理する3つの重要な要素が1行に凝縮されている点にあります。forループの構文は、いわばプログラマとの「契約」です。あなたは「(1)どこから始めるか」「(2)どこまで進むか」「(3)どのように進むか」を一行で宣言します。この契約こそが、forループを非常に堅牢で読みやすいものにしているのです。この設計思想により、意図しない無限ループといった致命的なバグの発生を未然に防ぎ、安全な反復処理を保証します。

forループの「契約」は、以下の3つの主要な構成要素から成り立っています。

* カウンタ変数(※)の初期化： ループが開始される前に一度だけ実行されます。ループの出発点を設定する処理です。
* 継続条件のチェック： 各反復処理が実行される前に評価されます。この条件式が真（true）である限り、ループは続行されます。
* カウンタの増分： 各反復処理のブロックが実行された後に実行されます。カウンタを更新し、ループが確実にゴールにたどり着くようにします。

※ カウンタ変数とは、あと何回繰り返すかを数えるための変数です。

ちなみに、慣習として、このような単純なループのカウンタ変数にはi、j、kといった一文字の変数がよく使われます。これはC言語のプログラムで頻繁に目にする伝統なので、ぜひ慣れておきましょう。

この3要素がどのように連携して動作するのか、0から9までの数字を順番に出力する具体的なコード例で見てみましょう。

```
int i;
//   1. 初期化      2. 継続条件    3. 増分
for (i = 0;        i < 10;       i++) {
    printf("%d\n", i);
}
```

このコードを分析すると、forループの3要素が明確に対応していることがわかります。

1. 初期化 (i = 0)： ループ開始前に、カウンタ変数iを0に設定します。
2. 継続条件 (i < 10)： 各反復の開始時にiが10未満かを確認します。この条件が満たされている間だけ、ループが継続します。
3. 増分 (i++)： printf文が実行された後、iの値が1増加します。これにより、iは0, 1, 2...と変化し、最終的に10になった時点で継続条件が偽（false）となり、ループは終了します。

さらに、forループは配列のようなデータ構造を処理する際にその真価を発揮します。カウンタ変数を配列のインデックスとして利用することで、すべての要素に順番にアクセスできます。以下の例は、配列内のすべての数値を合計するコードです。

```
int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = 0;
int i;

for (i = 0; i < 10; i++) {
    sum += array[i];
}
/* sum now contains array[0] + array[1] + ... + array[9] */
printf("Sum of the array is %d\n", sum);
```

この例では、カウンタ変数iが0から9まで変化するのに合わせてarray[0], array[1], ... array[9]というように、配列の各要素へアクセスしています。このように、反復回数が事前に明確な処理、特に配列の全要素に対する操作において、forループは非常に強力かつ安全な選択肢となります。

さて、反復回数が事前に決まっていない場合はどうすればよいでしょうか。次に、より柔軟な条件でループを制御できるwhileループを見ていきましょう。

## 3. whileループ：条件に基づく柔軟な反復処理

whileループの核心的な価値は、その柔軟性にあります。forループが「回数」に焦点を当てているのに対し、whileループは「特定の条件が真（true）である限り処理を継続する」という、よりシンプルな概念に基づいています。whileループは、初期化と増分処理を構文に含んでいないため、forループより構造がシンプルです。しかし、このシンプルさこそが、反復回数が事前に予測できない状況、例えばユーザーからの特定の入力があるまで待機する場合や、ある計算結果が特定の閾値に達するまで処理を繰り返す場合など、forループでは記述しにくいシナリオで不可欠な力となります。

whileループの基本構文は非常に簡潔です。

```
while (継続条件) {
    /* 条件が真である限り実行されるコードブロック */
}
```

ここで注目すべきは、forループが持っていた3つの構成要素（初期化、条件、増分）が、whileループでは分散して記述される点です。

* 初期化： ループの前に、条件判定に使われる変数を手動で初期化する必要があります。
* 条件： while文の括弧内に記述します。
* 増分（更新）： ループブロックの内部で、条件判定に使われる変数を手動で更新しなければなりません。

この構造上の違いは、特にループの終了条件を管理する上で重要な意味を持ちます。以下のforループと等価なwhileループの例を見てみましょう。このコードは10回処理を実行します。

```
int n = 0;       // 1. 初期化
while (n < 10) { // 2. 継続条件
    n++;         // 3. 増分（更新）
}
```

この例から分かるように、ループを正しく終了させるためには、ループ内部でのn++のような条件変数の更新処理が不可欠です。もしこの更新を忘れると、条件式が永遠に真となり、プログラムが停止しない「無限ループ」に陥ってしまいます。これは初心者が陥りやすい典型的なミスの一つです。 また、whileループは、常に真と評価される条件（例：while (1)）を与えることで、意図的に無限ループを記述することも可能です。

```
while (1) {
    /* 意図的に無限に実行したい処理 */
}
```

この柔軟性は強力な武器であると同時に、慎重な管理が求められることを意味します。

whileループは、条件に基づいて柔軟に反復を制御できる点が強みです。しかし、時にはループの実行フローをさらに細かく制御したい場合があります。次のセクションでは、そのための高度なテクニックであるbreakとcontinueについて解説します。

## 4. ループフローの高度な制御：breakとcontinue

forやwhileを使った基本的な反復処理だけでは、複雑な要件に効率的に対応できないことがあります。例えば、「配列を検索して、目的の要素が見つかったら、残りの要素を調べる必要はないのでループを抜けたい」あるいは「特定の条件を満たす要素だけ処理をスキップしたい」といったケースです。このような状況でプログラムのロジックをより精緻かつ効率的に実装するための戦略的ツールが、breakとcontinueという2つの命令です。

**break命令**

break命令は、ループをその場で即座に強制終了させるために使用します。breakが実行されると、プログラムの制御はループ構文の直後の文に移動します。これは、ループの継続条件がまだ真であっても関係ありません。

以下の例では、無限ループ（while (1)）を記述していますが、変数nが10に達した時点でif文の条件が真となり、breakが実行されます。その結果、ループは10回の反復で確実に停止します。

```
int n = 0;
while (1) {
    n++;
    if (n == 10) {
        break; // nが10になった瞬間にループを抜ける
    }
}
```

このように、breakは特定の条件が満たされた時点で反復処理全体を終了させたい場合に非常に有効です。

**continue命令**

continue命令は、breakとは異なりループ全体を終了させるのではなく、現在のイテレーション（反復処理）のみをスキップし、即座に次のイテレーションの開始地点（forループの場合は増分処理、whileループの場合は条件判定）に進むために使用します。

以下の例では、変数nが奇数（n % 2 == 1）の場合にcontinueが実行されます。結果として、偶数のみが出力されます。

```
int n = 0;
while (n < 10) {
    n++;

    /* nが奇数かどうかチェック */
    if (n % 2 == 1) {
        /* ループブロックの先頭に戻る */
        continue;
    }

    /* このコードはnが偶数の場合にのみ到達する */
    printf("The number %d is even.\n", n);
}
```

このコードの動作を追ってみましょう。例えばnが3になったとします。if文の条件 `n % 2 == 1` が真となり、continue文が実行されます。すると、その直後にあるprintfの行は即座にスキップされ、制御はループの先頭、つまりwhile (n < 10)の条件判定へとジャンプします。これが、奇数の場合にprintfが決して実行されない理由です。

breakが「ループからの脱出」であるのに対し、continueは「現在の回の処理を中断して次へ進む」という機能的な違いがあります。この2つを使いこなすことで、より複雑なロジックをシンプルに記述できるようになります。

ここまでで、forとwhileという2つの主要なループ構造と、そのフローを制御するbreakとcontinueについて学びました。最後のセクションでは、これらの知識を統合し、状況に応じて最適なループを選択するための指針をまとめます。

## 5. まとめ：適切なループの選択とベストプラクティス

これまでの解説で、C言語における主要なループ構文の機能と使い方を学んできました。しかし、真に品質の高いコードを書くためには、単に文法を知っているだけでは不十分です。それぞれのループが持つ特性を深く理解し、解決したい問題の性質に応じて最適なループ構造を選択する判断力が不可欠となります。

forループとwhileループのどちらを選択すべきか、その判断基準を以下のテーブルにまとめました。

|シナリオ|推奨ループ|理由|
|---|---|---|
|配列の全要素を処理するなど、反復回数が事前に明確な場合|forループ|初期化、条件、増分が一体となっており、ループの全体像を把握しやすく、無限ループのリスクが低い。|
|特定の条件が満たされるまで処理を繰り返すなど、反復回数が不確定な場合|whileループ|実行条件のみでループを制御するため、より柔軟な反復ロジックを記述できる。|

最後に、プログラムを学び始めた皆さんがC言語のループ処理を実践する上で、常に心に留めておくべき最も重要な3つのベストプラクティスを挙げます。

1. 無限ループの罠を回避する forループでは継続条件式を、whileループではループ内部での条件変数の更新を必ず確認してください。意図しない無限ループは、プログラムを停止させる深刻なバグの元です。特に覚えておくべき危険なパターンは、whileループ内でのcontinueの使い方です。**continue文の前にカウンタ変数を更新する処理があるか必ず確認してください。**これを怠ると、カウンタが更新されないままループの先頭に戻り続け、修正困難な無限ループに陥ります。
2. カウンタ変数のスコープを意識する forループの初期化式で宣言された変数（例：for (int i = 0; ...)）は、そのループ内でのみ有効です。一方、ループの外で宣言された変数はループ後も存在し続けます。変数のライフサイクルを理解し、適切に管理することがバグの少ないコードに繋がります。
3. 常に自分の選択に疑問を持つ 反復回数が決まっているなら、迷わずforループを使いましょう。その構造はコードの意図を明確にし、他の開発者が読んだときの可読性を高めます。もしwhileループを書いたなら、一度立ち止まって自問してください。「これはforループで書けないか？」と。もし答えが「Yes」なら、forループの方がほぼ間違いなく、より明確で安全な選択です。このシンプルな自己修正の習慣が、あなたのコード品質を劇的に向上させるでしょう。

ループ処理はプログラミングの基本であり、その応用範囲は無限大です。本ガイドで得た知識を基に、多くのコードを書き、様々な問題に挑戦することで、ぜひループ処理をマスターしてください。
