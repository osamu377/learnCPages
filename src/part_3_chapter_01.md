# 共用体



![auto vs heap](img/p3c1.jpg)

## 1. はじめに：共用体（Union）とは何か、なぜ重要なのか

ここでは、C言語における「共用体（Union）」という、一見単純ながらもメモリ管理とデータ表現において非常に強力なツールについて学びます。共用体をマスターすることは、メモリを効率的に利用し、柔軟なデータ構造を設計する上で不可欠なスキルです。

C言語の共用体（Union）とは、基本的に構造体（Struct）と似ていますが、決定的な違いが一つあります。それは、共用体は **複数の名前を同じ変数（メモリ領域）に割り当てる** という点です。

皆さんが既に慣れ親しんでいるであろう構造体と比較してみましょう。

* 構造体（Struct）: 内部の各メンバー変数が、それぞれ自身の独立したメモリ領域を持ちます。全体のサイズは、基本的に全メンバーのサイズの合計になります。
* 共用体（Union） : 全てのメンバーが、単一のメモリ領域を共有します。そのため、一度に有効な値を保持できるメンバーは一つだけです。

この「メモリを共有する」という特性が、共用体のすべての機能と利点の源泉となります。次のセクションでは、このメモリ共有の具体的な仕組みについて、さらに詳しく掘り下げていきましょう。

## 2. 共用体の基本原則：メモリ共有の仕組み

共用体のメモリ管理を理解することは、C言語プログラミングにおける効率性を追求する上で重要な鍵となります。このセクションでは、共用体がどのようにしてメモリを共有し、そのサイズがどのように決定されるのかを解き明かしていきます。

## 2.1. 構造体（Struct）との決定的な違い

前述の通り、構造体と共用体の最も根本的な違いはメモリの割り当て方にあります。

* 構造体は、宣言された全てのメンバーを同時に格納するため、各メンバーのサイズを合計した分（※）のメモリ領域を確保します。
* 対照的に、共用体は、どのメンバーも格納できる単一の共有メモリ領域のみを確保します。これにより、複数のデータ型の中から一つだけを保持する、という状況でメモリを大幅に節約することが可能になります。

※）実際には、コンパイラがこれに余分なパディング（詰め物）を加える可能性もあります。これは、CPUがメモリに効率的にアクセスできるよう、データの開始アドレスを特定のバイト境界に揃える「アライメント」という最適化のためです。C言語初心者はこれを無視しても問題ありません。

## 2.2. 共用体のサイズ決定ルール

では、その共有メモリ領域のサイズはどのように決まるのでしょうか。ルールは非常にシンプルです。

共用体全体のサイズは、**「最もサイズの大きいメンバーのサイズになる」**と定められています（※）。

※）こちらも構造体と同様、「アライメント」がプラスされることもありますが、初心者の理解を妨げるだけなので、以降、ないものとして説明します。

例えば、char型（1バイト）、int型（4バイト）、double型（8バイト）のメンバーを持つ共用体があった場合、その共用体のサイズは最も大きいdouble型のサイズである8バイトとなります。このルールこそが、共用体がメモリ効率化を実現する仕組みの核心です。

これらの基本原則を念頭に置くことで、次のセクションで紹介する具体的なユースケースへの理解がより深まるはずです。

## 3. 共用体の実践的ユースケース

理論を理解したところで、次はその知識を実践に結びつけることが重要です。このセクションでは、共用体を「いつ」「どのように」使うべきかという問いに答える、3つの具体的なユースケースを見ていきましょう。

### 3.1. ユースケース1：メモリ効率の最適化（タグ付き共用体）

大量のデータを扱うプログラムでは、わずかなメモリ使用量の削減が全体のパフォーマンスに大きな影響を与えることがあります。共用体は、このような状況でメモリ効率を最適化するために役立ちます。

ここで紹介するのが「タグ付き共用体」というデザインパターンです。これは、どのデータ型が現在共用体に格納されているかを示す「タグ」となるメンバーを、構造体内に共用体と一緒に保持する手法です。

**メモリ効率の悪い例（共用体を使わない場合）**

```
struct operator_inefficient {
    int type;
    int intNum;
    float floatNum;
    double doubleNum;
};
```

この構造体は、intNum, floatNum, doubleNum のうち一つしか使わない場合でも、常に全メンバー分のメモリを確保してしまいます。

**タグ付き共用体を使った改善例**

```
struct operator {
    int type; // どの型が有効かを示すタグ (例: 0=int, 1=float, 2=double)
              // int, probably better as an enum or macro constant
    union {
        int intNum;
        float floatNum;
        double doubleNum;
    } types;
};
```

この改善された構造体 operator のサイズは、「int 型の type メンバー」と「共用体内の最大型である double」のサイズの合計になります。これにより、使われないメンバーのためのメモリを確保する必要がなくなり、プログラム全体で大幅なメモリ節約が期待できます。なお、typeメンバーには、可読性と安全性を高めるために、enumやマクロ定数を使用することが推奨されます。

### 3.2. ユースケース2：データへの多様なアクセス方法の提供

一つのデータセットに対し、意味の分かりやすい「名前」によるアクセスと、ループなどで処理しやすい「インデックス」によるアクセスの両方を提供したい場合があります。共用体は、これをエレガントに実現します。

以下の Coins 共用体の例を見てみましょう。

```
union Coins {
    struct { // 無名構造体
        int quarter;
        int dime;
        int nickel;
        int penny;
    };
    int coins[4];
};
```

この例では、無名構造体と配列が同じメモリ領域を共有しています。これにより、以下のような2通りのアクセスが可能になります。

1. 名前によるアクセス: change.quarter や change.dime のように、可読性の高い名前で各データにアクセスできます。
2. インデックスによるアクセス: for ループ内で change.coins[i] のように、インデックスを用いてデータに反復アクセスできます。

どちらの方法でアクセスしても、操作しているのは同じ共有メモリです。これにより、コードの可読性と処理の効率性を両立させることができます。

実際に両方のアクセス方法が機能することを示す例を見てみましょう。

```
// 例：インデックスによるアクセスで値を設定
union Coins change;
int values[] = {10, 5, 20, 50}; // quarters, dimes, nickels, pennies
for(int i = 0; i < 4; ++i) {
    change.coins[i] = values[i];
}

// 名前によるアクセスで値を表示
printf("Quarters: %d, Dimes: %d\n", change.quarter, change.dime);
// 出力 -> Quarters: 10, Dimes: 5
```

これらのユースケースで登場した「無名」という概念は非常に便利です。次のセクションで、この応用テクニックについて詳しく見ていきましょう。

## 4. 応用テクニック：無名共用体

これまでの例で見てきたように、共用体や構造体に名前を付けない「無名」の定義は、コードをより簡潔にするための応用テクニックです。

「タグ付き共用体」の例をもう一度見てみましょう。共用体に types という名前を付けていました。

```
// 名前付き共用体の場合
struct operator {
    int type;
    union {
        int intNum;
        float floatNum;
        double doubleNum;
    } types; // "types" という名前
};

struct operator op;
op.type = 0;
op.types.intNum = 352; // "types" を経由してアクセス
```

ここで、共用体から名前を取り除くと、そのメンバーに直接アクセスできるようになります。

```
// 無名共用体の場合
struct operator {
    int type;
    union { // 名前がない！
        int intNum;
        float floatNum;
        double doubleNum;
    };
};

struct operator op;
op.type = 0;
op.intNum = 352; // 直接アクセスできる！
```

`op.types.intNum` という記述が `op.intNum` となり、より直接的でシンプルなコードになりました。これにより、コードの冗長性が減り、より直感的な記述が可能になります。

先ほどの `Coins` の例で見たように、このテクニックは無名構造体にも同様に適用でき、非常に柔軟なデータ構造の設計を可能にします。

それでは、ここで学んだ知識を定着させるために、演習問題に挑戦してみましょう。

## 5. 理解度チェック：演習問題

学習内容を確実に身につけるため、以下の演習問題に取り組んでください。理論を実際のコードに落とし込む良い練習になります。

**課題:** 21文字の char 配列と6つの int 配列を格納する共用体を作成してください。この共用体の int 配列メンバーに、指定された6つの整数値を初期化リストで設定します。その後、同じメモリ領域を char 配列として解釈し、その内容を「文字の連続」として、また「文字列」として出力してください。

以下のスターターコードを完成させてください。

```
#include <stdio.h>

/* ここに共用体を定義する */
union IntOrChar {
    int ints[6];
    char chars[21];
};

int main() {
    // このような初期化リストは、共用体/構造体の最初のメンバー（この場合はints）に代入される！
    union IntOrChar intCharacters = {{1853169737, 1936876900, 1684955508, 1768838432, 561213039, 0}};

    /* テストコード */
    printf("[");
    // 終端のヌル文字(chars[20])は出力しない。ループは19までとし、最後の文字(chars[19])はループ後に表示する。
    for(int i = 0; i < 19; ++i) {
        printf("%c, ", intCharacters.chars[i]);
    }
    printf("%c]\n", intCharacters.chars[19]);

    printf("%s\n", intCharacters.chars);

    return 0;
}
```

**期待される出力**

```
[), B, i, n, d, n, g, s, $, a, n, d, P,  , f, i,  , n, s, !]
)Bindngs$and P fi ns!
```

## 6. まとめ：共用体をマスターするためのキーポイント

本研修を通じて、C言語の共用体についてその基本原則から実践的な応用までを学びました。最後に、共用体を効果的に活用するための重要なポイントを要約します。

* メモリの共有
  * 共用体の最も基本的な性質であり、構造体との最大の違いです。全てのメンバーが単一のメモリ領域を共有します。
* サイズのルール
  * 共用体のサイズは、最も大きいサイズのメンバーによって決まります。
* 主な用途
  * タイプパニング: データの内部表現を、異なる型として解釈するために使用します。整数のバイト単位での操作などが典型例です。
  * メモリ節約: 複数のデータ型のうち、いずれか一つだけを格納する状況で「タグ付き共用体」として用いることで、メモリ使用量を大幅に削減します。
  * 柔軟なアクセス: 無名構造体/共用体と配列を組み合わせることで、名前による可読性の高いアクセスと、インデックスによる効率的な反復処理を両立させます。

共用体は日常的に使用するツールではないかもしれませんが、その仕組みを理解することは、C言語のメモリモデルに対する深い洞察を与えてくれます。ここで学んだ知識を武器に、メモリ効率が求められる挑戦的な課題にも自信を持って取り組んでください。
