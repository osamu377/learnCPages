#  引数の参照渡し

## イントロダクション

本章では、C言語における関数の引数の渡し方、特に「値渡し」と「参照渡し」の違いについて解説します。関数の基本的な動作を理解した新入社員を対象に、ポインタを活用して関数外の変数を直接操作する「参照渡し」の概念と実装方法を、具体的なコード例を通じて学習することを目的とします。


--------------------------------------------------------------------------------


## 1. はじめに：なぜ「参照渡し」を学ぶのか？

**関数が呼び出し元のデータを変更する** 必要がある場面は、プログラミングにおいて非常に多く発生します。この「参照渡し」を理解することは、より強力で効率的なプログラムを組むための重要な第一歩です。C言語の関数は、呼び出し元からデータを受け取る方法として、大きく分けて2つの基本的な仕組みを持っています。

一つは **「値渡し（Pass by Value）」** です。これはC言語のデフォルトの動作で、関数に **引数の「コピー」** を渡します。そのため、関数内でその引数をいくら変更しても、呼び出し元にある元の変数には一切影響を与えません。もう一つが **「参照渡し（Pass by Reference）」** です。これは、変数の値そのものではなく、**値が格納されている「メモリアドレス」** を渡す方法です。

本章では、C言語におけるポインタの概念を用いてこの「参照渡し」を実現し、**関数が呼び出し元のデータを直接変更できるようにする** 方法を学びます。このテクニックを習得することで、あなたの書くコードの可能性は大きく広がるでしょう。

## 2. 値渡し（Pass by Value）の基本と限界

参照渡しの必要性を理解するためには、まずC言語のデフォルトの動作である「値渡し」を正確に把握することが不可欠です。値渡しとは、関数に引数の「値のコピー」を渡す仕組みです。関数はオリジナルの変数ではなく、そのコピーを操作するため、関数内での変更が外部に影響を及ぼすことはありません。

この挙動を、数値を1つインクリメントするaddoneという関数を例に見てみましょう。

以下のコードとその実行結果を見てください。

**コード例：**


```
#include <stdio.h>

void addone(int n) {
    // nは関数内でのみ有効なローカル変数
    n++;
    // ここでのインクリメントは外部に影響しない
}

int main() {
    int n = 0; // 初期値を設定
    printf("Before: %d\n", n);
    addone(n);
    printf("After: %d\n", n);
    return 0;
}
```

実行結果の解説： このコードを実行すると、コンソールには以下のように表示されます。

```
Before: 0
After: 0
```

Before:とAfter:の出力が同じ0であることから、**addone関数がmain関数内の変数nをインクリメントするという期待通りの機能を発揮しなかった** ことが分かります。

どうしてそうなるのか、プログラムの動きをステップ・バイ・ステップで見てみましょう。

main関数内の変数nがaddone関数に渡される際、その値（この場合は0）だけがコピーされ、addone関数内のローカル変数nに代入されます。つまり、この段階では、**0という値が入った変数が、メモリ上にふたつ（main関数の変数`n`とaddone関数の変数`n`）存在する** わけです。

addone関数内でのn++という操作は、あくまでこのコピーされたローカル変数に対して行われます。

|関数|`n`に対する操作|
|---|---|
|main関数|初期値`0`が代入される|
|addone関数|`n++`でインクリメントされる|

しかしながら、この二つの変数は、それぞれ独立しています。別々のメモリ・アドレスを持った、別々の家なのです。そして、addone関数の`n`は関数スコープ、つまりその関数の中だけで有効なため、関数の処理が終了すると同時に破棄されます。結果として、main関数にある元の変数`n`には、初期値`0`が代入された状態のまま、何の変化ももたらされません。

このように、関数が呼び出し元のデータを変更できないという値渡しの限界は、多くの場面で問題となります。では、この問題をどのように解決すればよいのでしょうか？

その答えが、次のセクションで解説する「参照渡し」です。

## 3. 参照渡し（Pass by Reference）による解決策

値渡しの限界を克服するための鍵となる技術が **「ポインタ」** です。変数の値そのものを渡す代わりに、**その変数が格納されているメモリアドレス（ポインタ）を関数に渡す** ことで、関数は呼び出し元のスコープにある変数を直接「参照」し、変更することが可能になります。これが「参照渡し」の基本的な考え方です。

それでは、先ほどのaddone関数をポインタを使って修正し、参照渡しが機能する仕組みを3つのステップで見ていきましょう。

1. 関数の定義 (`void addone(int *n)`) 
    * 引数の型を`int`から`int *n`に変更します。このアスタリスク`*`は、この引数が単なる整数ではなく「整数へのポインタ」を受け取ることを意味します。つまり、関数は値そのものではなく、**値が格納されている「場所の情報（メモリアドレス）」** を受け取る準備をします。
2. 関数本体での操作 (`(*n)++`) 
    * 関数内で、ポインタ変数`n`が指し示すアドレスに格納されている実際の値にアクセスするために、再びアスタリスク`*`を使用します。これは **「デリファレンス（間接参照）」** と呼ばれる操作です。`(*n)`とすることでポインタが指す先の値そのものを取得し、その値をインクリメントします。これにより、呼び出し元の変数が直接変更されます。
3. 関数の呼び出し (`addone(&n)`)
    * 関数を呼び出す際には、変数`n`の前にアンパサンド **`&`（アドレス演算子）** を付けます。これにより、変数`n`の値ではなく、そのメモリアドレスがaddone関数に渡されます。

上の説明で、addone関数の中で、新たに変数'n'が作られて **いない** ことに注目してください。addone関数は、main関数で作られた「家」である`n`の住所（アドレス）を受け取って、その「家」（main関数で作られた、このプログラム全体を通じて、ひとつだけしかない`n`という「家」）の中にいる値を操作することになります。

以下のコードは、これらの変更を適用したものです。

**コード例：**

```
#include <stdio.h>

void addone(int *n) {
    // nは外部変数のメモリアドレスを指すポインタ
    (*n)++;
    // ポインタを介して元の変数の値をインクリメントする
}

int main() {
    int n = 0; // 初期値を設定
    printf("Before: %d\n", n);
    addone(&n); // nのメモリアドレスを渡す
    printf("After: %d\n", n);
    return 0;
}
```

実行結果の解説： このコードを実行すると、期待通りの結果が得られます。

```
Before: 0
After: 1
```

After:の出力で値が正しく1にインクリメントされていることが確認できます。これは、ポインタを介した参照渡しによって、**addone関数がmain関数内の変数nを直接操作する** ことに成功した証拠です。

この強力な原則は、整数のような単純な型だけでなく、次に示すように、より複雑なデータ構造である「構造体」にも応用することができます。

## 4. 応用：構造体とポインタ

参照渡しの考え方は、複数のデータを一つのまとまりとして扱う「構造体」を関数に渡す際に、特にその真価を発揮します。もし構造体を値渡しすると、構造体の全メンバがコピーされるため、データサイズが大きい場合には非効率です。しかし、ポインタを使えば、構造体のサイズに関わらず、メモリアドレスという小さなデータ一つを渡すだけで済むため、非常に効率的です。

ここでは、座標を表すpoint構造体のポインタを受け取り、そのxとyの値をそれぞれインクリメントするmove関数を例に、構造体へのポインタの利用方法を解説します。まず、point構造体を定義します。

```
typedef struct {
    int x;
    int y;
} point;
```

この構造体のポインタを引数として受け取るmove関数は、以下のように記述できます。

```
void move(point * p) {
    (*p).x++;
    (*p).y++;
}
```

ここで`(*p).x`という記法に注目してください。ポインタ`p`をまずデリファレンス`（*p）`して構造体そのものを取り出し、その後ドット`.`演算子でメンバ`x`にアクセスしています。

しかし、C言語ではこのような操作が頻繁に行われるため、より簡潔で直感的な短縮記法が用意されています。それが **アロー演算子 (`->`)** です。アロー演算子を使うと、先ほどのmove関数は次のように書き換えられます。

```
void move(point * p) {
    p->x++;
    p->y++;
}
```

ポインタ経由で構造体のメンバにアクセスする、これら2つの方法を比較してみましょう。

|構文|記法|説明|
|---|---|---|
|標準記法|(*p).x|ポインタpをまずデリファレンスして構造体そのものを取り出し、その後ドット.演算子でメンバxにアクセスする方法です。括弧が必須です。|
|アロー演算子|p->x|ポインタから直接構造体のメンバにアクセスするための、より簡潔で一般的な短縮記法です。Cプログラミングでは広くこの記法が使われます。|

`(*p).x`と`p->x`は完全に等価な操作ですが、アロー演算子 (`->`) の方がはるかに直感的でコードの可読性が高いため、一般的に推奨される方法です。

ここまでの理論的な学習を、次のセクションでは実践的な演習を通して、あなた自身のスキルとして確実なものにしていきましょう。

## 5. 実践演習：birthday関数の実装

新しい知識を定着させる最善の方法は、実際に手を動かしてコードを書くことです。この演習を通じて、参照渡しの理解を深めましょう。

演習の目的: person構造体のポインタを受け取り、そのageメンバを1つ増やすbirthdayという名前の関数を作成してください。

以下の土台となるコードを参考に、指定された箇所に関数を実装してください。

```
#include <stdio.h>

typedef struct {
    char * name;
    int age;
} person;

/* function declaration */
void birthday(person * p);

/* ここに関数を記述してください */


int main() {
    person john;
    john.name = "John";
    john.age = 27;

    printf("%s is %d years old.\n", john.name, john.age);
    birthday(&john);
    printf("Happy birthday! %s is now %d years old.\n", john.name, john.age);

    return 0;
}
```

この演習を終えたら、最後に本日の学習内容を総括するまとめのセクションに移ります。

## 6. まとめ：本章の学習ポイント

この章の締めくくりとして、本日学習した重要事項を再確認し、知識を整理しましょう。参照渡しは、C言語プログラミングにおける非常に強力なツールです。

本章で学んだ最も重要な概念は、以下の3点に要約されます。

1. 値渡しの挙動
    * C言語の関数はデフォルトで引数を「値渡し」で扱います。これは引数のコピーを作成するため、関数内で引数を変更しても、呼び出し元の元の変数は影響を受けません。
2. 参照渡しの実現
    * 関数が呼び出し元の変数を直接変更する必要がある場合、「参照渡し」を用います。これは、アドレス演算子 (`&`) を使って変数のメモリアドレスを渡し、関数側ではポインタ変数 (`*P`) を使ってそのアドレスを受け取り、デリファレンス (`*`) することで実現します。
3. 構造体への応用
    * 構造体へのポインタを扱う際は、アロー演算子 (`->`) を使用することで、コードを簡潔かつ直感的に記述できます。これは `(*p).member` と等価ですが、一般的に推奨される記法です。

参照渡しの概念を正しく理解し、使いこなすことは、効率的で柔軟なプログラムを設計する上で不可欠です。本章で学んだ知識は、今後のC言語プログラミングにおける様々な場面で必ず役立つでしょう。

