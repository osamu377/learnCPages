# ポインタ演算

## イントロダクション：なぜポインタ演算を学ぶのか？

この章は、C言語におけるポインタ演算を初心者の皆さんが習得するためのガイドです。ポインタが「メモリアドレスを格納する変数」であるという基本的な理解から一歩進み、ポインタ演算を学ぶことは、C言語プログラミングの核心に迫る上で不可欠です。効率的なメモリ操作、配列の走査、そしてパフォーマンスが求められる場面において、ポインタ演算は極めて重要な役割を果たします。具体的な演算方法を学ぶ前に、まずはポインタ演算がどのように機能するのか、その根底にある基本原則を理解することが重要です。

## 1. ポインタ演算の基本原則

ポインタ演算とは、ポインタが指し示すデータそのものではなく、ポインタが保持しているメモリアドレスに対して算術演算を行うことです。この操作は、通常の整数に対する演算とは根本的に異なります。

ポインタ演算における最も重要な原則は、演算がポインタが指すデータ型のサイズに応じて自動的にスケーリングされるという点です。これを簡潔に表現すると、次のようになります。

「ポインタを1つ進める」ことは、「ポインタが指すデータ型のサイズ分だけメモリアドレスを進める」ことを意味します。

例えば、int型のポインタを考えてみましょう。int型が4バイトの環境では、このポインタに 1 を加算すると、ポインタが保持するメモリアドレスの値は 1 ではなく 4 増加します。このスケーリング機能があるからこそ、プログラマは char、int、double といった異なるデータ型の配列を、型サイズを意識することなく同じ pointer++ という記述で安全に走査できるのです。

この基本原則を念頭に置き、具体的な4つの主要な演算子を見ていきましょう。

## 2. 主要なポインタ演算の実践

### 2.1. インクリメント (++)

インクリメント演算子 (++) は、ポインタをメモリ上の次の要素へ移動させる最も一般的な方法です。特に配列を順次処理する際に頻繁に利用されます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value %d - and address @ %x\n", i, intarray[i], &intarray[i]); 

    int *intpointer = &intarray[3]; // 配列の4番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 4番目の要素のアドレスと値を表示 
    
    intpointer++; // ポインタをインクリメントし、5番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 5番目の要素のアドレスと値を表示 

    return 0; 
}
```

このコードでは、intpointerは最初に配列の4番目の要素 (intarray[3]) を指しています。intpointer++ を実行すると、ポインタは5番目の要素 (intarray[4]) を指すように移動します。このとき、アドレスの値は 1 ではなく sizeof(int) (例えば4バイト) だけ増加している点に注意してください。これは 1 * sizeof(int)、つまり4バイトのアドレス移動に相当します。

要素を次に進めるのと同様に、前に戻すことも可能です。

### 2.2. デクリメント (--)

デクリメント演算子 (--) は、インクリメントとは逆に、ポインタをメモリ上の前の要素へ移動させます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value %d - and address @ %x\n", i, intarray[i], &intarray[i]); 

    int *intpointer = &intarray[4]; // 配列の5番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 5番目の要素のアドレスと値を表示 
    
    intpointer--; // ポインタをデクリメントし、4番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 4番目の要素のアドレスと値を表示 
    
    return 0; 
}
```

intpointerが5番目の要素 (intarray[4]) を指している状態から intpointer-- を実行すると、ポインタは4番目の要素 (intarray[3]) へと戻ります。この操作は、アドレスを 1 * sizeof(int) 分だけ減算することに相当します。

1つずつ移動するだけでなく、複数の要素を一度に飛び越えることもできます。

### 2.3. 加算 (+)

ポインタに整数を加算することで、複数の要素を一度に前方へジャンプさせることができます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value: %d - and address @ %x\n", i, intarray[i], &intarray[i]); 
    
    int *intpointer = &intarray[1]; // 配列の2番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 2番目の要素のアドレスと値を表示 
    
    intpointer += 2; // ポインタのアドレスを2要素分進め、4番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 4番目の要素のアドレスと値を表示 
    
    return 0; 
}
```

この例で intpointer += 2 を実行すると、アドレスが8バイト移動することに気づくでしょう。これは、ポインタ演算の基本原則によるものです。ポインタに整数 n を加算する操作は、実際にはアドレスに n * sizeof(データ型) を加算します。このケースでは 2 * sizeof(int) となり、2 * 4バイト = 8バイト の移動となるわけです。

前方にジャンプするのと同様に、後方にもジャンプすることが可能です。

### 2.4. 減算 (-)

ポインタから整数を減算することで、複数の要素を一度に後方へジャンプさせることができます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value: %d - and address @ %x\n", i, intarray[i], &intarray[i]); 
    
    int *intpointer = &intarray[4]; // 配列の5番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 5番目の要素のアドレスと値を表示 
    
    intpointer -= 2; // ポインタのアドレスを2要素分戻し、3番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 3番目の要素のアドレスと値を表示 
    
    return 0; 
}
```

intpointer が &intarray[4] を指している状態から intpointer -= 2 を実行すると、ポインタは2つ前の要素である &intarray[2] へと移動します。この場合、アドレスは 2 * sizeof(int) (8バイト) だけ減算されます。

これらの算術演算に加えて、ポインタ同士を比較することも重要な操作です。

## 3. その他のポインタ演算：比較

C言語では、ポインタに対して関係演算子 (>、<、== など) を使用して比較を行うことができます。ここで重要なのは、この比較がポインタの指す先の値ではなく、ポインタ自体が保持しているメモリアドレスを比較しているという点です。この機能は、例えばポインタが配列の有効な範囲内にあるかを確認したり、2つのポインタが同じメモリ位置を指しているかを判定したりする際に非常に役立ちます。

これらの概念を定着させるために、実際に手を動かして演習問題に取り組んでみましょう。

## 4. 実践演習

以下の演習は、ポインタ演算と配列の組み合わせについての理解を深めることを目的としています。

課題: intarrayの最後の3つの要素のアドレスを、intへのポインタの配列であるparrayにコピーしてください。

以下の開始コードの for ループ内に、ポインタ演算を用いて parray を正しく初期化するコードを記述してください。

```
#include <stdio.h>

int main() {
    int intarray[5] = {10,20,30,40,50};
    int *pointer = &intarray[2]; // ポインタを配列の3番目の要素（インデックス2）に初期設定する

    // ポインタ3つを格納する配列
    int *parray[3];

    // intarrayの最後の3要素のアドレスをparrayにコピーする
    // parrayとpointerを使用する
    int i;
    for (i = 0; i < 3; i++) {
        // ここにコードを記述
    }

    // テストコード
    for (i = 0; i < 3; i++) {
        if (parray[i] == &pointer[i]) {
            printf("Matched!\n");
        } else {
            printf("Fail\n");
        }
    }

    return 0;
}
```

補足：テストコード内の &pointer[i] という表現は、pointer + i と等価です。これはポインタ pointer が指すアドレスから i 要素分だけ進んだアドレスを意味し、皆さんが for ループ内で parray に設定すべきアドレスと一致するかを検証します。

## 5. まとめ

本ガイドでは、C言語におけるポインタ演算の基本原則と主要な操作について解説しました。ポインタの基本的な概念から一歩踏み出し、アドレスを直接操作するテクニックは、C言語プログラマにとって必須のスキルです。

この研修で学んだ最も重要なポイントは以下の通りです。

* ポインタ演算は、ポインタが保持するメモリアドレスを操作するものである。
* ポインタに対する加算・減算は、ポインタが指すデータ型のサイズに応じて自動的にスケーリングされる。
* これらの特性により、ポインタはC言語における効率的な配列操作の要となる。

これらの概念は、C言語を深く理解し、より高度で効率的なコードを書くための基礎となります。ぜひ繰り返し練習し、ポインタ演算を自在に扱えるようになってください。
