# 配列とポインタ

## イントロダクション

C言語のプログラミングにおいて、ポインタと配列の関係を深く理解することは、単なる文法の習得以上の意味を持ちます。この関係性をマスターすることは、メモリを効率的かつ安全に管理し、高性能なアプリケーションを構築するための foundational skill、つまり基礎体力となります。本資料は、皆さんがこの重要な概念を理論と実践の両面から理解し、自信を持って使いこなせるようになることを目的としています。

このトレーニングを通じて、以下の3つの主要な概念を学習します。

* 配列とポインタの等価性： C言語において、配列名がどのようにポインタとして機能するのか、その仕組みを解き明かします。
* mallocを用いた動的メモリ確保： プログラムの実行中に必要なメモリを柔軟に確保し、解放するテクニックを学びます。
* 2次元配列のメモリ管理： 1次元配列の知識を応用し、より複雑な2次元データ構造を動的に構築・管理する方法を習得します。


--------------------------------------------------------------------------------


## 1. 配列とポインタの根本的な関係

**本セクションのイントロダクション**

C言語プログラミングの核心に迫る概念の一つに、「配列名は、その配列の先頭要素を指す『定数ポインタ』として機能する」という事実があります。一見すると些細なことに思えるかもしれませんが、この理解こそが、後のポインタ演算や高度なメモリ操作を自在に操るための鍵となります。このセクションでは、コード例を通してこの関係性を具体的に検証し、その仕組みを明らかにしていきます。

**概念の実証：コードと出力の分析**

まず、母音の文字を格納したvowels配列を例にとり、そのアドレスと値がどのように表現されるかを見ていきましょう。

```
#include <stdio.h>

int main() {
    char vowels[] = {'A', 'E', 'I', 'O', 'U'};
    char *pvowels = vowels;
    int i;

    // アドレスを出力
    for (i = 0; i < 5; i++) {
        printf("&vowels[%d]: %p, pvowels + %d: %p, vowels + %d: %p\n", i, &vowels[i], i, pvowels + i, i, vowels + i);
    }

    // 値を出力
    for (i = 0; i < 5; i++) {
        printf("vowels[%d]: %c, *(pvowels + %d): %c, *(vowels + %d): %c\n", i, vowels[i], i, *(pvowels + i), i, *(vowels + i));
    }

    return 0;
}
```

このコードを実行すると、一般的に以下のような出力が得られます。（メモリアドレスは実行環境によって異なります）

|添字 (i)|参照方法|メモリアドレス|値|
|---|---|----|---|
|0|&vowels[0] / pvowels + 0 / vowels + 0|0x7ffee146da17||
||vowels[0] / *(pvowels + 0) / *(vowels + 0)||A|
|1|&vowels[1] / pvowels + 1 / vowels + 1|0x7ffee146da18||
||vowels[1] / *(pvowels + 1) / *(vowels + 1)||E|
|2|&vowels[2] / pvowels + 2 / vowels + 2|0x7ffee146da19||
||vowels[2] / *(pvowels + 2) / *(vowels + 2)||I|
|3|&vowels[3] / pvowels + 3 / vowels + 3|0x7ffee146da1a||
||vowels[3] / *(pvowels + 3) / *(vowels + 3)||O|
|4|&vowels[4] / pvowels + 4 / vowels + 4|0x7ffee146da1b||
||vowels[4] / *(pvowels + 4) / *(vowels + 4)||U|

**出力の分析**

* アドレスの等価性: 上の表から明らかなように、&vowels[i]（i番目の要素のアドレス）、pvowels + i（ポインタpvowelsにiを加算）、そしてvowels + i（配列名vowelsにiを加算）は、すべて同じメモリアドレスを指し示しています。これは、配列名vowels自体が配列の先頭要素へのポインタとして扱われているためです。pvowelsはvowelsを代入されたポインタ変数ですが、vowelsは配列名そのものであり、そのアドレスは変更不可能な「定数ポインタ」です。そのため、vowels = another_address; のような再代入はコンパイルエラーとなります。
* 値の等価性: 同様に、vowels[i]という馴染み深い配列表記と、*(pvowels + i)や*(vowels + i)といったポインタ表記（アドレスが指す先の値を参照する）は、全く同じ値を返します。C言語の内部では、vowels[i]という記述は*(vowels + i)と等価なものとして解釈されるのです。

**結論と次のセクションへの移行**

配列名がポインタとして機能するという事実を理解することで、私たちはメモリ上のデータにアクセスするための、より強力で統一的な視点を手に入れることができます。この知識は、コンパイル時ではなくプログラム実行時にメモリサイズを決定する「動的メモリ確保」へと続く扉を開きます。


---------------------------------------------------------------

## 2. 動的メモリ確保による配列の作成

**セクションの導入**

これまで扱ってきた配列は、プログラムをコンパイルする時点でそのサイズを決定する必要がある「静的配列」でした。しかし、ユーザの入力数に応じてデータを格納したい場合など、事前にサイズが確定できないケースは数多く存在します。このような状況で絶大な力を発揮するのが動的メモリ確保です。これにより、プログラム実行中に必要な分だけメモリを確保し、不要になれば解放することが可能となり、柔軟でメモリ効率の高いプログラムを作成できます。

### 2.1. 1次元配列の動的確保と解放

malloc（memory allocation）関数は、動的メモリ確保の最も基本的な手段です。以下のコードは、mallocを使って5文字分のメモリ領域を確保し、そこに値を格納する例です。

```
#include <stdio.h>
#include <stdlib.h> // mallocとfreeのために必要

int main() {
    int n = 5;
    // 5文字分のメモリを動的に確保
    char *pvowels = (char *) malloc(n * sizeof(char));

    pvowels[0] = 'A';
    pvowels[1] = 'E';
    *(pvowels + 2) = 'I'; // ポインタ表記でもアクセス可能
    pvowels[3] = 'O';
    *(pvowels + 4) = 'U';

    for (int i = 0; i < n; i++) {
        printf("%c ", pvowels[i]);
    }
    printf("\n");

    // 確保したメモリを解放
    free(pvowels);

    return 0;
}
```

ここで重要なのは、char *pvowels = (char *) malloc(n * sizeof(char)); という行です。この一行を分解して見ていきましょう。

1. sizeof(char): char型の変数が占めるメモリサイズ（通常は1バイト）を計算します。
2. n * sizeof(char): 必要な要素数 n を乗算し、確保すべき合計バイト数を算出します。
3. malloc(...): 計算されたバイト数分の連続したメモリブロックをヒープ領域から確保し、そのブロックの先頭アドレスを返します。
4. (char *): mallocが返す汎用的なポインタ型（void *）を、私たちが使用したい特定の型（この場合はchar *）に変換（キャスト）します。

確保されたメモリ領域には、ポインタpvowelsを介してアクセスします。ここで注目すべきは、pvowelsがポインタ変数であるにもかかわらず、pvowels[i]のような配列表記でアクセスできる点です。これは、前セクションで学んだ配列とポインタの等価性に基づいています。

そして、最も重要なのがメモリの解放です。mallocで確保したメモリは、不要になったら必ずfree(pvowels);を呼び出してシステムに返却しなければなりません。これを怠るとメモリリークが発生し、プログラムが長時間実行されるうちに利用可能なメモリを使い果たしてしまう原因となります。メモリの確保と解放は、プログラマが負うべき責任です。

### 2.2. 2次元配列の動的確保と解放

2次元配列を動的に確保する場合、少し工夫が必要です。1次元配列が「ポインタ」で扱えたのに対し、2次元配列は「ポインタへのポインタ（char **）」を使って管理します。これは、まず行を指すための「ポインタの配列」を確保し、次にその各ポインタが実際のデータ（各行）を指すようにメモリを確保する、という2段階の構造を取るためです。これは、まず各行の先頭アドレスを格納するための『住所録』（ポインタの配列）を作成し、次にその住所録の各項目が実際の『家』（各行のデータ）を指し示す、というイメージです。

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int nrows = 2;
    int ncols = 5;
    int i, j;

    // ステップ1: 行ポインタを格納するためのメモリ確保 (ポインタの配列)
    char **pvowels = (char **) malloc(nrows * sizeof(char *));

    // ステップ2: 各行の要素を格納するためのメモリ確保 (ループを使用)
    for (i = 0; i < nrows; i++) {
        pvowels[i] = (char *) malloc(ncols * sizeof(char));
    }

    // 値の代入
    pvowels[0][0] = 'A'; pvowels[0][1] = 'E'; pvowels[0][2] = 'I'; pvowels[0][3] = 'O'; pvowels[0][4] = 'U';
    pvowels[1][0] = 'a'; pvowels[1][1] = 'e'; pvowels[1][2] = 'i'; pvowels[1][3] = 'o'; pvowels[1][4] = 'u';

    for (i = 0; i < nrows; i++) {
        for(j = 0; j < ncols; j++) {
            printf("%c ", pvowels[i][j]);
        }
        printf("\n");
    }

    // 解放は確保と逆の順序で行う
    // まず各行を解放 (ループを使用)
    for (i = 0; i < nrows; i++) {
        free(pvowels[i]);
    }

    // 次に行ポインタの配列を解放
    free(pvowels);

    return 0;
}
```

メモリ解放のプロセスは、確保のプロセスと逆の順序で行う必要があります。まずループを用いて各行（pvowels[0], pvowels[1]など）のメモリを解放し、最後にそれらの行ポインタを格納していた配列（pvowels）自体を解放します。この順序を間違えると、解放されるべきメモリ領域へのアクセス手段を失い、メモリリークにつながります。

**結論と次のセクションへの移行**

1次元および2次元配列の動的メモリ確保と解放の技術は、C言語プログラマにとって必須のスキルです。この知識を武器に、プログラムの要求に応じて柔軟に形を変えるデータ構造を構築する準備が整いました。次のセクションでは、この技術を応用して、より実用的な問題に挑戦してみましょう。


---------------------------------------------------------------

## 3. 実践演習：不規則なデータ構造への応用

**本セクションのイントロダクション**

これまでに学んだ動的メモリ確保の知識は、単なる矩形の2次元配列だけでなく、より複雑なデータ構造を効率的に扱うためにも利用できます。このセクションでは、その応用例として「パスカルの三角形」を取り上げます。パスカルの三角形は、行ごとに要素数が異なる（1行目は1要素、2行目は2要素…）ため、メモリを無駄なく確保するには動的なアプローチが不可欠です。このような「不規則な（jagged）」配列の扱いは、動的確保の真価が問われる絶好の演習課題と言えるでしょう。

### 課題：パスカルの三角形

演習目標: パスカルの三角形の最初の3行を、メモリを無駄にすることなく（合計6要素分: 1 + 2 + 3 = 6）、動的に確保した2次元配列に格納し、出力してください。

以下のスケルトンコードを完成させてください。/* TODO: ... */とコメントされた部分が、皆さんが実装すべき箇所です。これまで学んだ知識を総動員して、課題に取り組んでください。

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int i, j;

    /* TODO: 2次元ポインタ変数をここで定義します (例: int **pnumbers;) */
    int **pnumbers;

    /* TODO: 3行分の行ポインタを保持するためのメモリを確保します */


    /* TODO: ループを使い、各行に必要な要素数だけメモリを確保してください */
    /* pnumbers[0] は 1要素分, pnumbers[1] は 2要素分, pnumbers[2] は 3要素分です */


    // 値の代入 (この部分は完成済み)
    pnumbers[0][0] = 1;
    pnumbers[1][0] = 1; pnumbers[1][1] = 1;
    pnumbers[2][0] = 1; pnumbers[2][1] = 2; pnumbers[2][2] = 1;

    // 出力 (この部分は完成済み)
    for (i = 0; i < 3; i++) {
        for (j = 0; j <= i; j++) {
            printf("%d ", pnumbers[i][j]);
        }
        printf("\n");
    }

    /* TODO: ループを使い、各行に割り当てたメモリを解放します */


    /* TODO: トップレベルのポインタ（行ポインタの配列）を解放します */


    return 0;
}
```

各TODOは、これまで学んできた以下の概念に対応しています。

* ポインタ変数の定義
* mallocを用いたメモリ確保
* freeを用いたメモリ解放


---------------------------------------------------------------

## 4. まとめ

**学習内容の総括**

本トレーニング資料を通じて、C言語におけるメモリ管理の根幹をなす重要な概念を学びました。ここで、主要なポイントを改めて振り返りましょう。

* 配列とポインタの等価性： 配列名は、その配列の先頭要素を指すポインタとして扱うことができます。これにより、array[i]と*(array + i)という2つの表記法が同じ意味を持つことを理解しました。
* 動的メモリ確保の力と責任： mallocを用いることで、プログラムの実行時に必要なサイズのメモリを柔軟に確保できます。しかし、その力にはfreeを用いて確保したメモリを確実に解放するという重大な責任が伴います。
* 複雑なデータ構造の管理： ポインタへのポインタ (**) を利用することで、2次元配列や、行ごとに長さが異なる不規則な配列でさえも、メモリを効率的に使用しながら動的に構築・管理できることを学びました。

**今後の学習への展望**

今回習得した配列、ポインタ、そして動的メモリ確保に関する知識は、皆さんが今後C言語でより高度なトピックを探求するための強固な土台となります。ポインタ演算の更なる応用、あるいは連結リストや木構造といった、より複雑で強力なデータ構造の学習に進む際、本資料で得た理解が必ずや助けとなるでしょう。

これからも探求心を忘れず、C言語の持つ力を最大限に引き出すプログラマを目指してください。
