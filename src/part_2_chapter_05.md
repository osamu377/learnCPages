# 配列とポインタ演算

![配列とポインタ演算の仕組み](img/p2c5.jpg)

## イントロダクション：なぜポインタ演算を学ぶのか？

この章では、**ポインタ演算を使って配列を操作する** 方法を、初心者の皆さんが習得するためのガイドです。

ポインタが「メモリアドレスを格納する変数」であるという基本的な理解から一歩進み、ポインタ演算を学ぶことは、C言語プログラミングの核心に迫る上で不可欠です。そして、 ポインタ演算が最大に威力を発揮するのは、それを使って配列を操作する場合です。

したがって、ポインタ演算を理解するためには、まず、配列とポインタの密接な関係、すべての基礎となる、両者の表裏一体の関係性を確認することが必要です。

では、そこから解説を始めましょう。

## 1. 配列とポインタの「秘密の契約」

C言語において、配列とポインタは表裏一体の関係にあります。一見すると異なる概念に見えますが、内部的には深く結びついており、この「秘密の契約」を理解することが、より複雑なポインタ操作をマスターするための戦略的基盤となります。

まず、C言語における文字列の基本ルールを再確認します。他の多くの言語と異なり、C言語には専用の「文字列型」が存在しません。代わりに、文字列は以下の2つのルールで表現されます。

* 文字の配列であること： 1文字 (char型) を複数、配列として並べます。
* 最後に必ずヌル文字(\0)を入れること： これが「文字列の終端」を示す目印となります。

例えば、"Hi" という2文字の文字列は、実際には 'H', 'i', '\0' の3文字、つまり3バイトのメモリ領域を必要とします。

そして、この配列とポインタを結びつける、C言語の最も重要なルールがこちらです。

「配列名そのものは、配列の先頭要素のアドレスを指すポインタとして扱われる」

このルールにより、ポインタ変数 p に配列 arr の先頭アドレスを代入する際、`p = &arr[0];` と書く代わりに、単に `p = arr;` と記述できます。これは、両者が本質的に等価であることをコンパイラが知っているからです。

この「密接な契約」があるからこそ、C言語では配列とポインタを柔軟に行き来できるのです。

## 2. 配列とポインタ演算

さて、ここが核心です。私たちが普段何気なく使っている arr[i] という配列の記法は、C言語のコンパイラによって内部的に *(arr + i) というポインタ演算に変換されています。

* arr (配列の先頭アドレス) に
* i (要素数) を加算し（ポインタ演算により i * sizeof(型) だけアドレスが移動）
* そのアドレスが指す場所の中身を * (間接参照演算子) で取り出す

これは単なるコンパイラの小手先の技ではありません。C言語がこれほど低レベルで効率的な操作を可能にする根幹の設計思想そのものであり、メモリアドレスを第一級の市民として扱えるようにするための基盤なのです。

皆さんは`arr[i]`について、すでによく知っていますね？ 第1部で扱いました。なので、ここではもう片方、ポインタ演算`*(arr + 1)`について、詳しく見ていきましょう。

**ポインタ演算** とは、ポインタが指し示すデータそのものではなく、ポインタが保持しているメモリアドレスに対して算術演算を行うことです。この操作は、通常の整数に対する演算とは根本的に異なります。

ポインタ演算における最も重要な原則は、**演算がポインタが指すデータ型のサイズに応じて自動的にスケーリングされる** という点です。足し算・引き算で使われる単位が、そのデータ型のサイズに、自動的に調整されるのです。これを簡潔に表現すると、次のようになります。

**「ポインタを1つ進める」ことは、「ポインタが指すデータ型のサイズ分だけメモリアドレスを進める」ことを意味する。**

例えば、int型とdouble型のポインタを考えてみましょう。ここでは、int型の値は4バイトのメモリに収められ、double型の値は8バイトのメモリに収められる環境(ごく普通の環境)を想定して、話を進めます。

この環境で、int型ポインタに 1 を加算すると、ポインタが保持するメモリアドレスの値は 1 ではなく **4** 増加します。double型ポインタに 1 を加算すると、メモリアドレスは **8** 増加します。

**int型(4byte)の場合の `p + 1`**

```
int * p;

     メモリ上のアドレス
      +--------+
p     | 0x1000 |  
      +--------+
p + 1 | 0x1004 |  <-- アドレスは+4される
      +--------+
```

**double型(8byte)の場合の `p + 1`**

```
double * p;

     メモリ上のアドレス
      +--------+
p     | 0x1000 |  
      +--------+
p + 1 | 0x1008 |  <-- アドレスは+8される
      +--------+
```

上の図で、ベースのアドレス(配列の先頭アドレス)`0x1000`はわかりやすいように、こちらで勝手に決めたものです。もし実際のベースが0x2145であれば、int型の`p + 1`は`0x2149`に、double型の`p + 1`は0x2153になります。とにかく、同じ`p + 1`でも、そのポインタがint型かdouble型かで、**アドレスの移動量が異なる** 点が、重要なのです。

このスケーリング機能があるからこそ、プログラマは char、int、double といった異なるデータ型の配列を、型サイズを意識することなく同じ pointer++ という記述で安全に走査できるのです。

これこそ、配列アクセスとポインタ操作が本質的に同じであることの論理的な証明です。以下のコードの出力結果を見ると、その等価性が明確になります。

```
#include <stdio.h>

int main() {
    char vowels[] = {'A', 'E', 'I', 'O', 'U'};
    char *pvowels = vowels;
    int i;

    // アドレスを表示
    for (i = 0; i < 5; i++) {
        printf("&vowels[%d]: %p, pvowels + %d: %p, vowels + %d: %p\n",
               i, &vowels[i], i, pvowels + i, i, vowels + i);
    }
    printf("\n");
    // 値を表示
    for (i = 0; i < 5; i++) {
        printf("vowels[%d]: %c, *(pvowels + %d): %c, *(vowels + %d): %c\n",
               i, vowels[i], i, *(pvowels + i), i, *(vowels + i));
    }

    return 0;
}
```

実行結果（例）

```
&vowels[0]: 0x7ffee146da17, pvowels + 0: 0x7ffee146da17, vowels + 0: 0x7ffee146da17
&vowels[1]: 0x7ffee146da18, pvowels + 1: 0x7ffee146da18, vowels + 1: 0x7ffee146da18
&vowels[2]: 0x7ffee146da19, pvowels + 2: 0x7ffee146da19, vowels + 2: 0x7ffee146da19
&vowels[3]: 0x7ffee146da1a, pvowels + 3: 0x7ffee146da1a, vowels + 3: 0x7ffee146da1a
&vowels[4]: 0x7ffee146da1b, pvowels + 4: 0x7ffee146da1b, vowels + 4: 0x7ffee146da1b

vowels[0]: A, *(pvowels + 0): A, *(vowels + 0): A
vowels[1]: E, *(pvowels + 1): E, *(vowels + 1): E
vowels[2]: I, *(pvowels + 2): I, *(vowels + 2): I
vowels[3]: O, *(pvowels + 3): O, *(vowels + 3): O
vowels[4]: U, *(pvowels + 4): U, *(vowels + 4): U
```

出力が示す通り、`&vowels[i]`、`pvowels + i`、`vowels + i` はすべて同じメモリアドレスを指し、`vowels[i]`、`*(pvowels + i)`、`*(vowels + i)` はすべて同じ値を返します。

## 3. 主要なポインタ演算の実践

配列とポインタの関係について、一通りの理解が得られたところで、ポインタ演算について、詳細に確認しましょう。

この基本原則を念頭に置き、具体的な4つの主要な演算子を見ていきましょう。

### 3.1. インクリメント (++)

インクリメント演算子 (++) は、ポインタをメモリ上の次の要素へ移動させる最も一般的な方法です。特に配列を順次処理する際に頻繁に利用されます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value %d - and address @ %x\n", i, intarray[i], &intarray[i]); 

    int *intpointer = &intarray[3]; // 配列の4番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 4番目の要素のアドレスと値を表示 
    
    intpointer++; // ポインタをインクリメントし、5番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 5番目の要素のアドレスと値を表示 

    return 0; 
}
```

このコードでは、intpointerは最初に配列の4番目の要素 (intarray[3]) を指しています。intpointer++ を実行すると、ポインタは5番目の要素 (intarray[4]) を指すように移動します。このとき、アドレスの値は 1 ではなく sizeof(int) (例えば4バイト) だけ増加している点に注意してください。これは 1 * sizeof(int)、つまり4バイトのアドレス移動に相当します。

要素を次に進めるのと同様に、前に戻すことも可能です。

### 3.2. デクリメント (--)

デクリメント演算子 (--) は、インクリメントとは逆に、ポインタをメモリ上の前の要素へ移動させます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value %d - and address @ %x\n", i, intarray[i], &intarray[i]); 

    int *intpointer = &intarray[4]; // 配列の5番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 5番目の要素のアドレスと値を表示 
    
    intpointer--; // ポインタをデクリメントし、4番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 4番目の要素のアドレスと値を表示 
    
    return 0; 
}
```

intpointerが5番目の要素 (intarray[4]) を指している状態から intpointer-- を実行すると、ポインタは4番目の要素 (intarray[3]) へと戻ります。この操作は、アドレスを 1 * sizeof(int) 分だけ減算することに相当します。

1つずつ移動するだけでなく、複数の要素を一度に飛び越えることもできます。

### 3.3. 加算 (+)

ポインタに整数を加算することで、複数の要素を一度に前方へジャンプさせることができます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value: %d - and address @ %x\n", i, intarray[i], &intarray[i]); 
    
    int *intpointer = &intarray[1]; // 配列の2番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 2番目の要素のアドレスと値を表示 
    
    intpointer += 2; // ポインタのアドレスを2要素分進め、4番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 4番目の要素のアドレスと値を表示 
    
    return 0; 
}
```

この例で intpointer += 2 を実行すると、アドレスが8バイト移動することに気づくでしょう。これは、ポインタ演算の基本原則によるものです。ポインタに整数 n を加算する操作は、実際にはアドレスに n * sizeof(データ型) を加算します。このケースでは 2 * sizeof(int) となり、2 * 4バイト = 8バイト の移動となるわけです。

前方にジャンプするのと同様に、後方にもジャンプすることが可能です。

### 3.4. 減算 (-)

ポインタから整数を減算することで、複数の要素を一度に後方へジャンプさせることができます。

```
#include <stdio.h> 
int main() { 
    int intarray[5] = {10,20,30,40,50}; 
    int i; 
    for(i = 0; i < 5; i++) 
        printf("intarray[%d] has value: %d - and address @ %x\n", i, intarray[i], &intarray[i]); 
    
    int *intpointer = &intarray[4]; // 配列の5番目の要素を指す 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 5番目の要素のアドレスと値を表示 
    
    intpointer -= 2; // ポインタのアドレスを2要素分戻し、3番目の要素を指すようにする 
    printf("address: %x - has value %d\n", intpointer, *intpointer); // 3番目の要素のアドレスと値を表示 
    
    return 0; 
}
```

intpointer が &intarray[4] を指している状態から intpointer -= 2 を実行すると、ポインタは2つ前の要素である &intarray[2] へと移動します。この場合、アドレスは 2 * sizeof(int) (8バイト) だけ減算されます。

これらの算術演算に加えて、ポインタ同士を比較することも重要な操作です。

## 4. その他のポインタ演算：比較

C言語では、ポインタに対して関係演算子 (>、<、== など) を使用して比較を行うことができます。ここで重要なのは、この比較がポインタの指す先の値ではなく、ポインタ自体が保持しているメモリアドレスを比較しているという点です。この機能は、例えばポインタが配列の有効な範囲内にあるかを確認したり、2つのポインタが同じメモリ位置を指しているかを判定したりする際に非常に役立ちます。

これらの概念を定着させるために、実際に手を動かして演習問題に取り組んでみましょう。

## 5. 実践演習

以下の演習は、ポインタ演算と配列の組み合わせについての理解を深めることを目的としています。

課題: intarrayの最後の3つの要素のアドレスを、intへのポインタの配列であるparrayにコピーしてください。

以下の開始コードの for ループ内に、ポインタ演算を用いて parray を正しく初期化するコードを記述してください。

```
#include <stdio.h>

int main() {
    int intarray[5] = {10,20,30,40,50};
    int *pointer = &intarray[2]; // ポインタを配列の3番目の要素（インデックス2）に初期設定する

    // ポインタ3つを格納する配列
    int *parray[3];

    // intarrayの最後の3要素のアドレスをparrayにコピーする
    // parrayとpointerを使用する
    int i;
    for (i = 0; i < 3; i++) {
        // ここにコードを記述
    }

    // テストコード
    for (i = 0; i < 3; i++) {
        if (parray[i] == &pointer[i]) {
            printf("Matched!\n");
        } else {
            printf("Fail\n");
        }
    }

    return 0;
}
```

補足：テストコード内の &pointer[i] という表現は、pointer + i と等価です。これはポインタ pointer が指すアドレスから i 要素分だけ進んだアドレスを意味し、皆さんが for ループ内で parray に設定すべきアドレスと一致するかを検証します。

## 6. まとめ

本ガイドでは、C言語におけるポインタ演算の基本原則と主要な操作について解説しました。ポインタの基本的な概念から一歩踏み出し、アドレスを直接操作するテクニックは、C言語プログラマにとって必須のスキルです。

この研修で学んだ最も重要なポイントは以下の通りです。

* ポインタ演算は、ポインタが保持するメモリアドレスを操作するものである。
* ポインタに対する加算・減算は、ポインタが指すデータ型のサイズに応じて自動的にスケーリングされる。
* これらの特性により、ポインタはC言語における効率的な配列操作の要となる。

これらの概念は、C言語を深く理解し、より高度で効率的なコードを書くための基礎となります。ぜひ繰り返し練習し、ポインタ演算を自在に扱えるようになってください。
