# 条件分岐



![C言語の条件分岐ガイド](img/p1c4.jpg)

## イントロダクション

この章での学習の目的は、プログラムの動作を制御するための根幹技術である条件分岐の基礎を完全に理解することです。条件分岐は、特定の状況に応じてプログラムの振る舞いを変化させるための仕組みであり、あらゆるソフトウェア開発において不可欠なスキルです。この資料を通じて、その基本構文と応用テクニックを体系的に学んでいきましょう。

---------------------------------------------------------------

## 1. はじめに：プログラムにおける意思決定

このセクションでは、プログラミングにおける「意思決定」の概念を解説します。これは、私たちが日常生活で行う意思決定と非常によく似ています。状況に応じて最適な行動を選択するように、プログラムもまた、与えられた条件に応じて最適な処理を選択する必要があります。この能力こそが、単なる計算機だったプログラムに、状況に応じて判断し、動的に振る舞う「知性」を与えるのです。

私たちの人生において、常に何らかの意思決定が求められるように、プログラムもさまざまな選択肢の中から判断を下す必要があります。例えば、「もし特定の条件が満たされたならば、この処理を実行する」といった具合です。C言語では、このような意思決定の構造を非常にシンプルに記述できます。

```
int target = 10;
if (target == 10) {
    printf("Target is equal to 10");
}
```

このコードは、変数targetの値が10と等しいかどうかを「判断」し、もし等しければメッセージを出力します。これが、プログラムにおける意思決定の核心です。

次のセクションでは、この判断の基礎となる最も基本的な構文、if文について詳しく学んでいきます。

## 2. 基本的な条件分岐：if文

プログラムに「プランB」を持たせたいとき、どうすればよいでしょうか？ if文は、まさにそのためのツールです。これはプログラムの流れを制御するための最も基本的かつ不可欠な構成要素であり、あらゆる条件分岐ロジックの出発点となります。

if文のコア機能は、指定された式が真（true）か偽（false）かを評価し、その結果が真であった場合にのみ、特定のコードブロックを実行するというものです。言い換えれば、「もし〜ならば、〜を実行する」というロジックをプログラム上で実現します。

先の例if (target == 10)で見たように、2つの変数が等しいかどうかを評価するためには、==（イコール2つ）という比較演算子を使用します。

注意： C言語で最もよくある間違いの一つが、比較の==と代入の=を混同することです。if (target = 10)と書いてしまうと、targetに10が代入され、その代入式の結果（この場合は10、C言語では非ゼロなので真と評価される）が条件となってしまいます。常に比較には==（イコール2つ）を使用することを徹底してください。

もちろん、等しいかどうかだけでなく、大小関係を評価することも可能です。不等号演算子（<や>）を用いることで、値の比較に基づいた条件分岐を実装できます。

```
int foo = 1;
int bar = 2;

if (foo < bar) {
    printf("foo is smaller than bar.");
}

if (foo > bar) {
    printf("foo is greater than bar.");
}
```

上記のコードでは、最初のif文でfoo < bar（1は2より小さい）が評価されます。この式は真であるため、「foo is smaller than bar.」というメッセージが出力されます。一方、2番目のif文のfoo > bar（1は2より大きい）は偽であるため、その中のprintf文は実行されません。

しかし、if文だけでは「条件が満たされなかった場合」に何をするかを明示的に定義できません。この課題を解決するのが、次にご紹介するif-else文です。

## 3. 条件が偽の場合の処理：if-else文

プランAがうまくいかなかった時のために、「プランB」が必要になることはありませんか？ if文はプランAを提供しますが、その条件が満たされなかった場合に何が起こるでしょうか。そこでelseが、より堅牢なプログラムを作成するための不可欠なツールとして登場します。

elseキーワードは、if文の式が偽（false）と評価されたときに実行されるコードブロックを定義するために使用されます。これにより、「もし条件Aが真ならば処理Xを、さもなければ処理Yを実行する」という明確な二者択一のロジックを構築できます。

```
int foo = 1;
int bar = 2;

if (foo < bar) {
    printf("foo is smaller than bar.");
} else {
    printf("foo is greater than bar.");
}
```

この例では、foo < barが真であるため、ifブロック内のprintf文が実行され、elseブロックは無視されます。もしfooの値が3であれば、foo < barは偽となり、elseブロック内のprintf文が実行されることになります。この構造により、プログラムは必ずどちらか一方の道を確実に選択するようになります。

しかし、現実世界の選択肢は常に二者択一とは限りません。3つ以上の選択肢から1つを選ぶ必要がある場合はどうすればよいでしょうか。その答えが、次のelse if文にあります。

## 4. 複数の選択肢を扱う：else if文

このセクションでは、3つ以上の選択肢から1つを選ぶような、より複雑な意思決定をプログラムで実現するためのelse if文を学びます。これにより、条件分岐の表現力が飛躍的に向上します。

複数のifとelseを「連鎖させる（chaining）」ことで、多岐にわたる条件分岐を体系的に構築できます。これがelse if文の役割です。この構造を使うことで、「もしAならばXを、そうでなくもしBならばYを、それ以外ならばZを」といった多段階のロジックを記述できます。

変数fooとbarの比較を例に、「より小さい」「等しい」「より大きい」という3つの状態を評価してみましょう。

```
int foo = 1;
int bar = 2;

if (foo < bar) {
    printf("foo is smaller than bar.");
} else if (foo == bar) {
    printf("foo is equal to bar.");
} else {
    printf("foo is greater than bar.");
}
```

この構造の最も重要な特性は、効率性と排他性です。条件は上から順に評価され、一つでも真と評価されたブロックが実行されると、後続のelse ifやelseは完全に無視されます。これにより、不要な評価をスキップできるだけでなく、複数の条件が同時に真になりうる場合でも、必ず一つの処理だけが実行されることが保証されます。

さらに複雑なロジックを構築するためには、条件の入れ子（ネスト）や論理演算子といった応用テクニックがあります。次のセクションで、これらの強力な手法を見ていきましょう。

## 5. 特定の値に基づいた効率的な分岐：switch-case文

これまで学んだ `else if` 文は非常に強力ですが、もしチェックしたい条件が「1つの変数の値が何であるか」という点に集中している場合、コードが少し読みづらく（冗長に）なってしまうことがあります。

例えば、サイコロの目（1〜6）に応じて処理を変えたい場合、`else if` を5回も書くのは大変です。このような「特定の値による多方向への分岐」を、よりスッキリと、かつ効率的に記述するために用意されているのが **switch-case文** です。

`switch` 文は、1つの変数の値を評価し、その値に一致する `case` ラベルへ「ジャンプ」する仕組みです。

### 基本的な構文

```c
int dice = 2;

switch (dice) {
    case 1:
        printf("1が出ました。\n");
        break;
    case 2:
        printf("2が出ました。\n");
        break;
    case 3:
        printf("3が出ました。\n");
        break;
    default:
        printf("4以上の目が出ました。\n");
        break;
}

```

このコードの動きを分解してみましょう。

#### A. `case` ラベル

`switch` の後ろのカッコ内の値（この場合は `dice`）が、`case` の後ろに書かれた定数と一致するかをチェックします。一致すれば、そこからプログラムの実行が始まります。

#### B. `break` 文（重要！）

各 `case` ブロックの最後にある `break` は、「スイッチから抜け出す」ための命令です。
**もし `break` を書き忘れると、次の `case` の中身まで連続して実行されてしまいます。** これを「フォールスルー（Fall-through）」と呼びます。意図的に使うこともありますが、初心者のうちは「`case` と `break` はセット」と覚えておくのが安全です。

#### C. `default` ラベル

どの `case` にも一致しなかった場合に実行される場所です。これは `if-else` 文における最後の `else` と同じ役割を果たします。いわば、プログラムの「セーフティネット」です。

### `switch` 文が適している場面

`switch` 文は非常に便利ですが、どんな条件分岐にも使えるわけではありません。以下の特徴を理解しておきましょう。

* **整数または文字の比較に限定**: C言語の `switch` 文は、基本的に `int` 型（整数）や `char` 型（文字）の「一致（==）」しか判定できません。「10より大きいか」といった**範囲の判定は `if` 文の領分**です。
* **可読性の向上**: 選択肢が4つ、5つと増えていく場合、`else if` を並べるよりも `switch` を使ったほうが、「何に基づいて分岐しているのか」がひと目で分かるようになります。

---

これで、C言語における条件分岐の主要な道具がすべて揃いました。状況に応じて `if-else` と `switch-case` を使い分けることが、美しくバグの少ないプログラムへの第一歩です。

## 6. 応用的な条件分岐のテクニック

ここまでのセクションで学んだif, if-else, else ifという基本構造を組み合わせることで、より現実的で精緻なプログラムロジックを構築できます。このセクションでは、そのための応用テクニックを2つ紹介します。

### 6.1. 条件の入れ子（ネスト）構造

if-else文の中に、さらにif-else文を配置することを「ネスト（入れ子）」と呼びます。これにより、ある条件が満たされた後、さらに詳細な条件で処理を分岐させることが可能になります。

以下のコードは、「ピーナッツの瓶」を例にしたネスト構造です。

```
int peanuts_eaten = 22;
int peanuts_in_jar = 100;
int max_peanut_limit = 50;

if (peanuts_in_jar > 80) {
    if (peanuts_eaten < max_peanut_limit) {
        printf("Take as many peanuts as you want!\n");
    }
} else {
    if (peanuts_eaten > peanuts_in_jar) {
        printf("You can't have anymore peanuts!\n");
    } else {
        printf("Alright, just one more peanut.\n");
    }
}
```

このロジックをステップバイステップで分析してみましょう。

1. 外側のif: まずpeanuts_in_jar > 80（瓶の中のピーナッツは80個より多いか？）が評価されます。100 > 80なので、この条件は真です。
2. 内側のif: 次に、外側のifブロックの中にあるpeanuts_eaten < max_peanut_limit（食べた数は上限より少ないか？）が評価されます。22 < 50なので、この条件も真です。
3. 最終出力: 結果として、「Take as many peanuts as you want!」が出力されます。

もし最初の条件（peanuts_in_jar > 80）が偽であったなら、プログラムはelseブロックに進み、そこにある内側のif-else構造で次の判断を行っていたでしょう。

このように、ネスト構造は条件の依存関係を表現するために不可欠です。「瓶に十分なピーナッツがある」という親条件が満たされて初めて、「食べたピーナッツの上限数」という子条件を評価する意味が生まれます。この階層的な判断こそが、複雑で現実的なロジックを構築する鍵となります。

### 6.2. 論理演算子による複数条件の評価

2つ以上の式を組み合わせて、より複雑な単一の条件を評価したい場合があります。その際に役立つのが論理演算子です。

* AND演算子 (&&)
  * 機能: A && Bのように使い、AとBの両方の式が真の場合にのみ、全体が真と評価されます。
  * 典型的な利用シーン: ユーザー名とパスワードが両方とも正しいか検証する、年齢が18歳以上かつ65歳未満であるかを確認するなど、複数の条件が同時に満たされる必要がある厳格なシナリオで使用します。
  * 例:
* OR演算子 (||)
  * 機能: A || Bのように使い、AとBのいずれか一方、または両方の式が真の場合に、全体が真と評価されます。
  * 典型的な利用シーン: ユーザーが「管理者」または「スーパーユーザー」の権限を持っているか確認する、入力された値が「y」または「Y」であるかを判定するなど、複数の条件のうち少なくとも一つが満たされれば良い、より柔軟なシナリオで使用します。
  * 例:
* NOT演算子 (!)
  * 機能: 式の結果を反転させます。真は偽に、偽は真になります。特によく使われるのが!=で、「等しくない」ことを評価します。
  * 典型的な利用シーン: ファイルが存在しない場合にエラー処理を行う、ユーザーが特定のグループに所属していないことを確認するなど、条件の不成立をトリガーにしたい場合に使用します。
  * 例:

これらの応用テクニックを駆使することで、プログラムの意思決定能力は格段に向上します。次のセクションでは、ここまでに学んだ知識を実践的な演習で確認してみましょう。

## 7. 実践演習：知識の応用

理論的な知識を確かなスキルに変えるためには、実際に自分の手でコードを書く実践が不可欠です。この演習を通じて、if, else if, elseの知識を応用し、具体的な問題を解決する力を養いましょう。

演習目標: guessNumber関数内に、与えられた数値guessが555と等しいか、それより大きいか、小さいかを判断するif-else if-else文を構築してください。

要件: 以下の3つの条件に基づいて、指定されたメッセージを出力するようにしてください。

* guessが555と等しい場合、「Correct. You guessed it!」と出力する。
* guessが555より小さい場合、「Your guess is too low.」と出力する。
* guessが555より大きい場合、「Your guess is too high.」と出力する。

**重要事項: printf文の末尾に、必ず改行文字\nを追加することを忘れないでください。**

以下のスターターコードには、main関数内に3つのguessNumber呼び出しが含まれています。あなたのロジックが、低い場合・高い場合・正しい場合の3つのシナリオすべてで正しく動作するかをテストするためのものです。

**スターターコード:**

```
#include <stdio.h>

void guessNumber(int guess) {
    // TODO: ここにコードを記述してください
}

int main() {
    guessNumber(500);
    guessNumber(600);
    guessNumber(555);
}
```

## 8. まとめ：条件分岐の未来

この研修資料を通じて、C言語における条件分岐の基礎を学びました。最後に、主要な概念を振り返りましょう。

* if文: 条件が真の場合にコードを実行する基本構造。
* if-else文: 条件が真の場合と偽の場合で処理を分ける二者択一の構造。
* else if文: 3つ以上の選択肢から1つを選ぶための多段階の構造。
* ネスト構造: 条件分岐の中にさらに条件分岐を配置する応用テクニック。
* 論理演算子 (&&, ||, !): 複数の条件を組み合わせて複雑な評価を行うためのツール。

条件分岐は、C言語プログラミングにおける単なる一機能ではありません。それはアルゴリズムの根幹をなし、ゲーム、OS、業務アプリケーションといった、あらゆる複雑なソフトウェアの動作を支える基盤技術です。

今回学んだ知識は、皆さんのプログラミングにおける「語彙」を飛躍的に増やしました。これからは、現実世界の問題を「もし〜ならば」という条件の連続として捉え、それをコードに翻訳する訓練を積んでください。その実践こそが、優れたソフトウェア開発者への最短の道です。
