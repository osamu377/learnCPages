# 動的メモリ確保

## イントロダクション

C言語におけるメモリ管理は、堅牢なソフトウェアを設計する上での核心的技術です。メモリ確保には大きく分けて二つの戦略が存在します。一つは、関数内のローカル変数などが利用するスタック領域での静的確保です。スタックは高速で自動的に管理されますが、確保できるサイズに限りがあり、変数の寿命はそのスコープに束縛されます。

これに対し、本稿で詳解する動的メモリ確保は、ヒープと呼ばれる広大で柔軟なメモリプールから、プログラムの実行時に必要なメモリを確保する手法です。この能力こそがC言語のパワーの源泉であり、実行時までサイズが不確定なデータを扱ったり、複雑なデータ構造を構築したりするための、不可欠な戦略的基盤となります。

ここでは、そうしたプロフェッショナルな世界への第一歩として、下に示す手順をしっかり頭に入れてください。

1. **必要なサイズのメモリを実行時に確保する**
1. **確保したメモリを利用する**
1.  **利用後、不要になったら解放する**

## 1. 動的メモリ確保とは何か

動的メモリ確保とは、プログラムの実行中に、任意のサイズのメモリブロックを確保・解放する技術です。このアプローチの核心的な利点は、**プログラムを作成した時点ではデータのサイズを事前に知らなくても、データを保存できる** 点にあります。ユーザー入力、ファイルの内容、ネットワーク通信など、コンパイル時には予測不可能な情報量に対応する上で、この技術は絶対不可欠です。

次にその実現に不可欠なツール群について見ていきましょう。

## 2. 動的確保を支える3つのコア要素

動的メモリ確保のライフサイクルは、「確保」「利用」「解放」の3フェーズで構成されます。C言語は、このライフサイクルをプログラマの管理下に置くための3つの主要な構成要素、すなわち malloc、sizeof、free を提供します。これらのツールは互いに連携し、メモリを安全かつ効率的に管理する仕組みを支えています。

### 2.1 メモリの確保: malloc 関数

malloc（memory allocation）は、メモリを確保する、動的確保の心臓部となる関数です。

* 目的: 指定されたバイトサイズのメモリ空間を予約し、そのブロックへのアクセス手段を提供します。
* 戻り値: 確保したメモリブロックの先頭アドレスを指す void 型のポインタ（void *）を返します。void * は「型情報を持たない汎用ポインタ」であり、特定のデータ型に紐付いていません。これにより malloc はあらゆるデータ型のために汎用的にメモリを確保できますが、このポインタは型情報を持たないため、直接中身を参照（デリファレンス）することはできません。
* 型キャスト: malloc が返す汎用的な void * は、実際に使用する前に特定のポインタ型へ変換しなければなりません。この変換プロセスを型キャストと呼びます。
* 上記例の (person *) が型キャストであり、void * を person 型のポインタへ明示的に変換しています。これによりコンパイラは、そのアドレスの先にあるデータの構造を理解できるようになります。

### 2.2 正確なサイズの取得: sizeof 演算子

sizeof は malloc の重要な相棒ですが、これは関数ではなく演算子です。その最大の特徴は、値がコンパイル時に決定される点にあります。コンパイラは sizeof(型) という記述を、そのデータ型がメモリ上で占有する正確なバイト数（size_t 型の整数）に置き換えます。例えば sizeof(person) は、person 構造体を格納するために必要なバイト数を返します。実行時に動作する malloc と組み合わせることで、環境に依存せず、常に正確なサイズのメモリを確保できるのです。

### 2.3 メモリの解放: free 関数

free は、動的に確保したメモリをシステムに返却し、再利用可能な状態に戻すための関数です。この役割の正確な理解は、メモリリークという致命的なバグを防ぐ上で極めて重要です。free(myperson) を呼び出すと、myperson というポインタ変数が指し示している先のデータ領域が解放されます。

極めて重要なのは、**free がポインタ変数自体（例: myperson）を削除するわけではない** という事実です。解放後も myperson 変数は存在し続け、解放済みで無効となったアドレスを指したままになります。

これらのツール群が実際にどう連携するのか、次のセクションで具体的なコードを通じて段階的に見ていきましょう。

## 3. 実践：動的確保のステップ・バイ・ステップ

前セクションで学んだ理論（malloc, sizeof, free）を統合し、ここで具体的な person 構造体を例に、動的メモリ確保の完全なプロセスを追体験します。

まず、ここで使用する person 構造体を以下に定義します。

```
typedef struct {
    char * name;
    int age;
} person;
```

### 3.1 ステップ1: ポインタの準備とメモリ確保

動的確保は、確保したメモリのアドレスを格納するポインタ変数の準備と、malloc による実際の確保を一行で行うのが一般的です。

```
person * myperson = (person *) malloc(sizeof(person));
```

この一行は、以下の3つの処理を連続して実行しています。

1. sizeof(person): person 構造体に必要なメモリサイズをコンパイル時に計算します。
2. malloc(...): 1で計算されたサイズのメモリブロックを確保し、その先頭アドレスを void * 型で返します。
3. person * myperson = (person *) ...: ポインタ変数 myperson を宣言し、malloc が返したアドレスを person * 型にキャストして代入します。

この時点で myperson は、person 構造体を格納するための有効なメモリ領域を指しており、利用可能な状態になります。

### 3.2 ステップ2: メモリへのアクセスと利用

確保したメモリ領域は、ポインタを介してアクセスします。ポインタが指す先の構造体メンバにアクセスするには、アロー演算子 -> を使用します。

```
myperson->name = "John";
myperson->age = 27;
```

### 3.3 ステップ3: メモリの解放

動的に確保したメモリの利用が完了したら、必ず free 関数を呼び出してシステムに返却しなければなりません。この解放処理はプログラマの責務であり、これを怠ることはメモリリークを引き起こします。

```
free(myperson);
```

メモリリークは、プログラムが確保したメモリを解放しないまま保持し続けるバグです。長時間稼働するアプリケーションでは、リークが蓄積して利用可能なメモリを枯渇させ、最終的にシステム全体のパフォーマンス低下やクラッシュを招く、極めて深刻な問題です。

正しく実装するだけでなく、動的メモリ管理に潜む重大なリスクを理解することが、プロのソフトウェアアーキテクトには求められます。次のセクションでは、安全なコードを書くための鉄則を解説します。

## 4. 鉄則：安全なメモリ管理とダングリングポインタの回避

動的メモリ管理の技術的な側面をマスターするだけでは不十分です。深刻なバグを防ぐためには、安全なプログラミングのための規律が不可欠です。ここでは、メモリ解放後のポインタが引き起こす致命的な問題、ダングリングポインタに焦点を当てます。

### 4.1 ダングリングポインタの危険性と対策

free 関数の挙動について以下の重要な注意事項があります。

**free は myperson 変数そのものを削除するのではなく、単にそれが指し示す先のデータを解放するだけである** ということです。free() を呼び出した後も、ポインタ変数 myperson は解放済みのメモリ領域のアドレスを保持し続けます。このような、もはや有効ではないメモリ領域を指し示すポインタは **「ダングリングポインタ（dangling pointer）」** と呼ばれます。

この状態のポインタを介してメモリにアクセスしようとする行為は、プログラムの動作を未定義にします。解放された領域はOSによって即座に別の目的に再割り当てされる可能性があり、そこへのアクセスはデータの破壊やプログラムの即時クラッシュなど、予測不能で追跡困難なバグの温床となります。解放後のポインタへのアクセスは厳禁です。

解放後のポインタへのアクセスを防ぐための最も堅牢な防御策は、free() を呼び出した直後にポインタへ NULL を代入することです。

```
free(myperson);
myperson = NULL;
```

これにより、ポインタは明確に無効な場所を指すことになり、万が一誤ってアクセスしようとした場合に（多くの実行環境で）プログラムが即座にクラッシュするため、バグの早期発見に繋がります。これは全てのCプログラマが遵守すべき規律です。

これまでの知識を定着させるため、最後に実践的な演習に移りましょう。

## 5. 演習：知識の適用

ここまでの学習内容を確実に身につけるため、実際にコードを書いて動的メモリ確保を実践する演習を行います。理論を実践に移すことで、より深い理解が得られます。

### 5.1 課題

この演習の目的は、point 構造体のインスタンスを動的に確保することです。

### 5.2 演習コード

以下のコードのコメント /* ... */ で示された部分に、point 構造体を動的に確保するためのコードを記述してください。

```
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x;
    int y;
} point;

int main() {
    point * mypoint = NULL;

    /* Dynamically allocate a new point
    struct which mypoint points to here */

    mypoint->x = 10;
    mypoint->y = 5;
    printf("mypoint coordinates: %d, %d\n", mypoint->x, mypoint->y);

    free(mypoint);
    return 0;
}
```

### 5.3 期待される出力

プログラムが正しく完成した場合、コンソールには以下の出力が表示されます。これにより、あなたのコードが正しく動作しているか自己評価することができます。

```
mypoint coordinates: 10, 5
```
