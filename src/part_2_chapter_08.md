# auto と static

## イントロダクション:記憶クラス指定子

ここでは、C言語における変数の **生存期間** と **有効範囲** という、プログラムの安定性を左右する重要な概念について学びます。特に、初心者がつまずきやすい`auto`と`static`という2つの記憶クラス指定子に焦点を当てます。これらの違いを正確に理解し、適切に使い分けることは、意図しないバグを防ぎ、信頼性と保守性の高いコードを書くための不可欠なスキルです。この資料を通じて、変数の振る舞いを深く理解し、より高度なプログラミングへの第一歩を踏み出しましょう。


---------------------------------------------------------------

## 1. 基本となる auto 変数

このセクションでは、C言語における最も基本的で一般的な変数であるauto変数について解説します。私たちが普段、関数内で何気なく宣言しているローカル変数の正体は、実はこのauto変数です。そのデフォルトの挙動を正確に理解することは、C言語プログラミングの基礎を固める上で極めて重要です。

**auto変数（自動変数）とは**

auto変数は、関数やブロック内で宣言されるローカル変数のデフォルトの型です。その名の通り、特定のスコープ内で「自動的」に生成・破棄される性質を持っています。

以下に、auto変数の主要な特徴をまとめます。

* キーワード autoキーワードを使って明示的に宣言することも可能ですが、関数内で宣言された変数はデフォルトでautoとして扱われるため、通常はこのキーワードは省略されます。
* 有効範囲（スコープ） 変数が宣言された関数内、またはブロック（{}で囲まれた範囲）内に限定されます。スコープ外からはアクセスすることはできません。
* 生存期間 auto変数の寿命は非常に短く、一時的です。
  * 関数が呼び出されるたびに、メモリ（スタック領域）上に新しく生成されます。
  * 関数の処理が終了すると、その変数はメモリから完全に消滅し、確保されていた領域は解放されます。
  * このため、関数を再度呼び出しても、以前の値が保持されていることはありません。
* 初期値 宣言時に明示的に値を代入して初期化しない場合、その変数には**不定な値（通称：ごみデータ）**が入っています。これは予期せぬバグの温床となるため、必ず初期化する習慣をつけましょう。

auto変数の「関数呼び出しごとにリセットされる」という性質は、一時的な計算には非常に便利ですが、状態を記憶する必要がある場合には不向きです。この点が、次にご紹介するstatic変数との決定的な違いとなります。


---------------------------------------------------------------


## 2. 状態を記憶する static 変数

前のセクションでは、関数が終わるとその役割も記憶もすべて失うauto変数を学びました。もしauto変数が「一度きりの仕事人」だとすれば、static変数は「プログラムの歴史を記憶する書記官」です。static変数は、プログラムの実行が開始されてから終了するまで、その値を保持し続ける特殊な変数です。この「状態を記憶する」という強力な特性は、特定のプログラミング課題をエレガントに解決するための鍵となります。

**static変数（静的変数）とは**

static変数は、その名の通りメモリ上の位置が「静的」に固定され、プログラムのライフサイクル全体を通じて生存する変数です。関数が終了してもその値は破棄されず、次回の呼び出し時に同じ値を参照・更新できます。

以下に、static変数の主要な特徴をauto変数と比較しながら見ていきましょう。

* キーワード 変数をstaticとして機能させるためには、データ型の前に **`static`キーワードを付けて明示的に宣言する** 必要があります。
* 有効範囲（スコープ） static変数のスコープは、宣言された場所によって異なります。
  * 関数内で宣言した場合: スコープはauto変数と同様に、その関数内に限定されます。外部から直接アクセスすることはできません。
  * 関数外で宣言した場合: スコープはそのファイル全体に限定されます。これは単なる制限ではなく、意図的な設計手法です。staticを付けることで、他のファイルからの意図しない変更を防ぐ「プライベートなグローバル変数」を作成できます。このテクニックは、特に大規模なプロジェクトでコードの安全性を保つために不可欠です。
* 生存期間 auto変数とは全く異なり、非常に長い寿命を持ちます。
  * プログラムが開始される前にメモリが確保され、一度だけ生成されます。
  * 関数が終了しても消滅せず、プログラムが終了するまでメモリ上に存在し続けます。
  * このため、関数の呼び出しをまたいで値を保持することができます。
* 初期値 auto変数との重要な違いとして、明示的に初期化しない場合でも、コンパイラによって自動的に0で初期化されるという特性があります。この違いを意識することが、バグを未然に防ぐ鍵となります。

---------------------------------------------------------------

## 3. C言語における4つのメモリ領域

今度はメモリ管理の点から、auto変数とstatic変数をみてみましょう。

前章で、メモリ空間にはスタック領域とヒープ領域があることを学びました。auto変数はすなわち基本的なローカル変数ですから、スタック領域に作成されます。では、static変数や、関数の外で宣言されるグローバル変数は、どうでしょう？ どちらの領域に入るのでしょうか？

どちらでもない、というのが正解です。

実は、プログラムが利用する主なメモリ領域は、スタック、ヒープを含め、ぜんぶで4つあります。

* プログラム領域(テキスト領域)
* データ領域
* スタック領域
* ヒープ領域

各領域の役割を簡潔に見ていきましょう。

|領域名|格納されるもの|確保・解放のタイミング|特徴|
|---|---|---|---|
|テキスト領域|プログラムのコード（機械語）|プログラム起動時～終了時|プログラム実行中に変更されることはない。プログラマが直接意識する必要はほとんどない。|
|データ領域|グローバル変数、静的変数（static）|プログラム起動時～終了時|プログラムが終了するまで値が保持される。|
|スタック領域|ローカル変数、関数の引数、関数の戻りアドレス|関数の呼び出し時～関数終了時|自動的に確保・解放が行われる。|
|ヒープ領域|プログラム実行中に動的に確保されるデータ|プログラマが手動で確保・解放する|任意のタイミングで必要なサイズのメモリを確保できる。|

この全体像を把握することが、メモリ管理を理解する上での重要なポイントとなります。

ところで、static変数には、上で説明した「関数をまたいで値を保持する」使い方のほかに、「グローバル変数のスコープをファイル内に限定する」という重要な役割もあります。次のセクションでは、これらの特性が実際のコードでどのように活かされるのかを具体的に見ていきます。

---------------------------------------------------------------

## 3. 実践的な比較と用例

ここまではautoとstaticの理論的な違いを学んできました。このセクションでは、両者の特性を比較表で整理し、実際のコード例を通して、どのような場面でどちらを選択するべきかを具体的に解説します。

**auto と static の特性比較**

これまでの内容を以下の表にまとめました。この違いを常に意識することが、適切な使い分けの第一歩です。

|特性|auto 変数|static 変数|
|---|---|---|
|生存期間|関数呼び出しの間|プログラム実行中全体|
|有効範囲|ブロック内|宣言場所による（関数内 or ファイル内）|
|初期値|不定値（ごみデータ）|0|
|宣言方法|キーワードは通常省略|staticキーワードを明示|

### 用例1：関数呼び出し回数のカウント

問題: あるレースに参加したランナーの数をカウントしたいとします。ランナーが1人参加するたびにrunner()という関数が呼ばれると仮定して、合計人数をカウントするプログラムを考えてみましょう。

**auto変数を使った失敗例**

まず、auto変数でカウンターを実装してみます。

```
#include <stdio.h>

int runner() {
    int count = 0; // auto変数
    count++;
    return count;
}

int main() {
    printf("%d ", runner()); // 1人目
    printf("%d ", runner()); // 2人目
    return 0;
}
// 期待する出力: 1 2
// 実際の出力: 1 1
```

このコードは期待通りに動作しません。runner()が呼び出されるたびに、全く新しいcount変数がメモリ上に生まれ、0で初期化されます。関数が終わるとその変数は破棄されるため、前回の呼び出しの記憶は完全に失われます。

**static変数を使った成功例**

次に、カウンター変数をstaticに変更してみましょう。

```
#include <stdio.h>

int runner() {
    static int count = 0; // static変数
    count++;
    return count;
}

int main() {
    printf("%d ", runner()); // 1人目
    printf("%d ", runner()); // 2人目
    return 0;
}
// 実際の出力: 1 2
```

今度は期待通りに動作しました。ここで重要なのは、static int count = 0; という初期化処理は、プログラムの開始前に一度だけ行われるということです。これはrunner()関数が繰り返し実行されるフローの一部ではありません。そのため、countの値は関数が終了してもメモリに保持され続け、呼び出すたびに正しくインクリメント（+1）されていきます。

### 用例2：グローバル変数のスコープ限定

staticのもう一つの強力な用途は、グローバル変数を「カプセル化」することです。以下の2つのファイルで構成されるプログラムを見てみましょう。

**module.c**

```
// module.c
#include <stdio.h>

// 他のファイルからもアクセス可能なグローバル変数
int public_counter = 0;

// このファイル内からのみアクセス可能な静的グローバル変数
static int private_counter = 0;

void count_up() {
    public_counter++;
    private_counter++;
    printf("private_counter is now %d\n", private_counter);
}
```

**main.c**

```
// main.c
#include <stdio.h>

// module.cで定義された変数を参照することを宣言
extern int public_counter;
// extern static int private_counter; // この行はコンパイルエラーになる！

// module.cで定義された関数プロトタイプ宣言
void count_up();

int main() {
    public_counter = 100; // OK: 他のファイルからアクセス可能
    printf("public_counter is now %d\n", public_counter);

    // private_counter = 50; // NG: アクセス不可のためコンパイルエラー

    count_up(); // module.cの関数を呼び出す

    return 0;
}
```

main.cからpublic_counterはexternキーワードで参照し、値を変更できます。しかし、private_counterにアクセスしようとすると、コンパイラはそれを見つけられず、リンカエラーを引き起こします。なぜなら、staticキーワードによってprivate_counterのスコープがmodule.cファイル内に完全に閉じられているからです。

このように、staticはファイル間で共有する必要のないグローバル変数を隠蔽し、意図しない外部からの変更を防ぎ、コードの安全性を劇的に高めます。

理論と具体例を通じて、両者の違いが明確になったことでしょう。では最後に、知識を定着させるための演習問題に取り組んでみましょう。

--------------------------------------------------------------------------------


## 4. 理解度チェック：演習問題

これまでに学んだ知識を実践的な問題に応用することで、特にstatic変数の強力な特性についての理解を深めていきましょう。

### 問題

sum()という関数があります。この関数は呼び出されるたびに引数numを受け取ります。これまでのnumの合計値を計算して返すようにsum()関数を完成させてください。

**条件：**

* 関数の外で合計値を保持する変数（グローバル変数）を使用してはなりません。
* sum()関数の引数はint numの一つのみとします。

**スターターコード**

```
#include <stdio.h>

int sum (int num) {
    // ここにコードを記述
}

int main() {
    printf("%d \n",sum(55));  // 期待される出力: 55
    printf("%d \n",sum(45));  // 期待される出力: 100
    printf("%d \n",sum(50));  // 期待される出力: 150
    return 0;
}
```

### 解答と解説

この問題は、static変数の「関数呼び出しをまたいで値を保持する」特性を利用することで解決できます。

**解答コード**

```
#include <stdio.h>

int sum (int num) {
    // 合計値を保持するためのstatic変数を宣言
    static int total = 0;

    // 現在の合計値に引数を加算
    total += num;

    // 合計値を返す
    return total;
}

int main() {
    printf("%d \n",sum(55));
    printf("%d \n",sum(45));
    printf("%d \n",sum(50));
    return 0;
}
```

**解説**

この解決策が機能する理由は、変数totalがstaticで宣言されているためです。

1. static int total = 0; はプログラムの実行開始時に一度だけ実行され、totalは0で初期化されます。
2. 最初のsum(55)の呼び出しで、totalは55になります。関数が終了しても、この55という値はメモリに保持されます。
3. 次のsum(45)の呼び出しでは、保持されていた55に45が加算され、totalは100になります。
4. 同様に、sum(50)では100に50が加算され、150が返されます。

このように、static変数はグローバル変数を汚さずに、関数内に閉じた形で状態を管理するための強力なツールとなります。この演習を通じて、その実践的な価値を体感できたことでしょう。


---------------------------------------------------------------

## 5. まとめ

この研修資料では、C言語における2つの基本的な記憶クラス指定子、autoとstaticについて、その特性と実践的な使い方を学びました。変数の「生存期間」と「有効範囲」をコントロールするこれらのキーワードは、プログラムの挙動を正確に制御する上で欠かせない知識です。

最後に、両者の使い分けの指針を再確認しましょう。

* auto変数 関数内の**「使い捨て」の道具**。計算が終われば跡形もなく消える、最も基本的で安全な選択肢です。
* static変数 プログラムの**「記憶」を司る特殊な道具**。値を保持し続けるか、外部から隠すという明確な目的がある場合にのみ使用します。

これらの記憶クラス指定子を意識し、場面に応じて適切に使い分けること。それが、バグが少なく、他の開発者にも意図が伝わりやすい、保守性の高いコードを書くための重要な一歩となります。この知識を活かし、より堅牢なCプログラムを構築していきましょう。

